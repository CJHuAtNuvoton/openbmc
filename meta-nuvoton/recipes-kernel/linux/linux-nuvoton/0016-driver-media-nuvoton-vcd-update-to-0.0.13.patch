From 7eb58e6205d6a92ca71ce2e973cd12dc596ab92a Mon Sep 17 00:00:00 2001
From: Joseph Liu <kwliu@nuvoton.com>
Date: Fri, 25 Dec 2020 13:56:58 +0800
Subject: [PATCH 1/2] driver: media: nuvoton: vcd: update to 0.0.13

1. clear graphic ram if getting invalid resolution
2. use regmap to improve i/o performance

Signed-off-by: Joseph Liu <kwliu@nuvoton.com>
---
 drivers/media/platform/nuvoton/npcm750_vcd.c | 852 +++++++++++--------
 1 file changed, 485 insertions(+), 367 deletions(-)

diff --git a/drivers/media/platform/nuvoton/npcm750_vcd.c b/drivers/media/platform/nuvoton/npcm750_vcd.c
index 1b5290b6a42d..a2a7a9d8365a 100644
--- a/drivers/media/platform/nuvoton/npcm750_vcd.c
+++ b/drivers/media/platform/nuvoton/npcm750_vcd.c
@@ -32,7 +32,7 @@
 #include <asm/fb.h>
 #include <linux/completion.h>
 
-#define VCD_VERSION "0.0.12"
+#define VCD_VERSION "0.0.13"
 
 #define VCD_IOC_MAGIC     'v'
 #define VCD_IOCGETINFO	_IOR(VCD_IOC_MAGIC,  1, struct vcd_info)
@@ -221,6 +221,23 @@
 #define  INTCR2_GIHCRST	BIT(5)
 #define  INTCR2_GIVCRST	BIT(6)
 
+#define INTCR3 0x9c
+#define INTCR3_GMMAP_MASK	GENMASK(10, 8)
+#define INTCR3_GMMAP_128MB	0x00000000
+#define INTCR3_GMMAP_256MB	0x00000100
+#define INTCR3_GMMAP_512MB	0x00000200
+#define INTCR3_GMMAP_1GB	0x00000300
+#define INTCR3_GMMAP_2GB	0x00000400
+
+#define ADDR_GMMAP_128MB	0x07000000
+#define ADDR_GMMAP_256MB	0x0f000000
+#define ADDR_GMMAP_512MB	0x1f000000
+#define ADDR_GMMAP_1GB		0x3f000000
+#define ADDR_GMMAP_2GB		0x7f000000
+
+/* Total 16MB, but 4MB preserved*/
+#define GMMAP_LENGTH	0xC00000
+
 #define MFSEL1 0x0c
 #define  MFSEL1_DVH1SEL	BIT(27)
 
@@ -276,6 +293,11 @@
 
 #define VCD_KVM_BW_PCLK 120000000UL
 
+#define GET_RES_RERTY			3
+#define GET_RES_TIMEOUT	300
+#define GET_RES_VALID_RERTY		3
+#define GET_RES_VALID_TIMEOUT	100
+
 struct class *vcd_class;
 static const char vcd_name[] = "NPCM750 VCD";
 
@@ -283,25 +305,25 @@ struct vcd_info {
 	u32 vcd_fb;
 	u32 pixelclk;
 	u32 line_pitch;
-	int hdisp;
-	int hfrontporch;
-	int hsync;
-	int hbackporch;
-	int vdisp;
-	int vfrontporch;
-	int vsync;
-	int vbackporch;
-	int refresh_rate;
-	int hpositive;
-	int vpositive;
-	int bpp;
-	int r_max;
-	int g_max;
-	int b_max;
-	int r_shift;
-	int g_shift;
-	int b_shift;
-	int mode;
+	u32 hdisp;
+	u32 hfrontporch;
+	u32 hsync;
+	u32 hbackporch;
+	u32 vdisp;
+	u32 vfrontporch;
+	u32 vsync;
+	u32 vbackporch;
+	u32 refresh_rate;
+	u32 hpositive;
+	u32 vpositive;
+	u32 bpp;
+	u32 r_max;
+	u32 g_max;
+	u32 b_max;
+	u32 r_shift;
+	u32 g_shift;
+	u32 b_shift;
+	u32 mode;
 	u32 reg;
 	u32 reg_val;
 };
@@ -339,6 +361,7 @@ struct npcm750_vcd {
 	struct vcd_info info;
 	struct list_head list;
 	void __iomem *base;
+	struct regmap *vcd_regmap;
 	struct regmap *gcr_regmap;
 	struct regmap *gfx_regmap;
 	u32 frame_len;
@@ -357,9 +380,9 @@ struct npcm750_vcd {
 
 typedef struct
 {
-	char* name;
-	int hdisp;	// displayed pixels i.e. width
-	int vdisp;	// displayed lines i.e. height
+	u8* name;
+	u32 hdisp;	// displayed pixels i.e. width
+	u32 vdisp;	// displayed lines i.e. height
 } res_tlb;
 
 static const res_tlb res_tlbs[] = {
@@ -398,42 +421,51 @@ static const res_tlb res_tlbs[] = {
 	{"1920 x 1200", 1920, 1200},
 };
 
-static const int restlb_cnt = sizeof(res_tlbs) / sizeof(res_tlb);
+static const size_t restlb_cnt = sizeof(res_tlbs) / sizeof(res_tlb);
 
-static void npcm750_vcd_update(struct npcm750_vcd *vcd, u32 reg,
-			       unsigned long mask, u32 bits)
+static void npcm750_vcd_claer_gmmap(struct npcm750_vcd *priv)
 {
-	u32 t = readl(vcd->base + reg);
+	struct regmap *gcr = priv->gcr_regmap;
+	u32 intcr3, gmmap;
+	void __iomem *baseptr;
 
-	t &= ~mask;
-	t |= (bits & mask);
-	writel(t, vcd->base + reg);
-}
-
-static u32 npcm750_vcd_read(struct npcm750_vcd *vcd, u32 reg)
-{
-	u32 t = readl(vcd->base + reg);
+	regmap_read(gcr, INTCR3, &intcr3);
+	gmmap = (intcr3 & INTCR3_GMMAP_MASK);
 
-	return t;
-}
+	switch (gmmap){
+	case INTCR3_GMMAP_128MB:
+		baseptr = ioremap(ADDR_GMMAP_128MB, GMMAP_LENGTH);
+		break;
+	case INTCR3_GMMAP_256MB:
+		baseptr = ioremap(ADDR_GMMAP_256MB, GMMAP_LENGTH);
+		break;
+	case INTCR3_GMMAP_512MB:
+		baseptr = ioremap(ADDR_GMMAP_512MB, GMMAP_LENGTH);
+		break;
+	case INTCR3_GMMAP_1GB:
+		baseptr = ioremap(ADDR_GMMAP_1GB, GMMAP_LENGTH);
+		break;
+	case INTCR3_GMMAP_2GB:
+		baseptr = ioremap(ADDR_GMMAP_2GB, GMMAP_LENGTH);
+		break;
+	}
 
-static void npcm750_vcd_write(struct npcm750_vcd *vcd, u32 reg, u32 val)
-{
-	writel(val, vcd->base + reg);
+	memset(baseptr, 0, GMMAP_LENGTH);
+	iounmap(baseptr);
 }
 
-static u8 npcm750_vcd_is_mga(struct npcm750_vcd *vcd)
+static u8 npcm750_vcd_is_mga(struct npcm750_vcd *priv)
 {
-	struct regmap *gfxi = vcd->gfx_regmap;
+	struct regmap *gfxi = priv->gfx_regmap;
 	u32 dispst;
 
 	regmap_read(gfxi, DISPST, &dispst);
 	return ((dispst & DISPST_MGAMODE) == DISPST_MGAMODE);
 }
 
-static u32 npcm750_vcd_hres(struct npcm750_vcd *vcd)
+static u32 npcm750_vcd_hres(struct npcm750_vcd *priv)
 {
-	struct regmap *gfxi = vcd->gfx_regmap;
+	struct regmap *gfxi = priv->gfx_regmap;
 	u32 hvcnth, hvcntl, apb_hor_res;
 
 	regmap_read(gfxi, HVCNTH, &hvcnth);
@@ -446,9 +478,9 @@ static u32 npcm750_vcd_hres(struct npcm750_vcd *vcd)
 		VCD_MAX_WIDTH : apb_hor_res;
 }
 
-static u32 npcm750_vcd_vres(struct npcm750_vcd *vcd)
+static u32 npcm750_vcd_vres(struct npcm750_vcd *priv)
 {
-	struct regmap *gfxi = vcd->gfx_regmap;
+	struct regmap *gfxi = priv->gfx_regmap;
 	u32 vvcnth, vvcntl, apb_ver_res;
 
 	regmap_read(gfxi, VVCNTH, &vvcnth);
@@ -461,9 +493,9 @@ static u32 npcm750_vcd_vres(struct npcm750_vcd *vcd)
 		VCD_MAX_HIGHT : apb_ver_res;
 }
 
-static void npcm750_vcd_local_display(struct npcm750_vcd *vcd, u8 enable)
+static void npcm750_vcd_local_display(struct npcm750_vcd *priv, u8 enable)
 {
-	struct regmap *gcr = vcd->gcr_regmap;
+	struct regmap *gcr = priv->gcr_regmap;
 
 	if (enable) {
 		regmap_update_bits(gcr, INTCR, INTCR_LDDRB, ~INTCR_LDDRB);
@@ -474,20 +506,26 @@ static void npcm750_vcd_local_display(struct npcm750_vcd *vcd, u8 enable)
 	}
 }
 
-static int npcm750_vcd_dvod(struct npcm750_vcd *vcd, u32 hdelay, u32 vdelay)
+static int npcm750_vcd_dvod(struct npcm750_vcd *priv, u32 hdelay, u32 vdelay)
 {
-	npcm750_vcd_write(vcd, VCD_DVO_DEL,
+	struct regmap *vcd = priv->vcd_regmap;
+
+	regmap_write(vcd, VCD_DVO_DEL,
 			(hdelay & VCD_DVO_DEL_MASK) |
 			((vdelay & VCD_DVO_DEL_MASK) << VCD_DVO_DEL_VSYNC_DEL_OFFSET));
 
 	return 0;
 }
 
-static int npcm750_vcd_get_bpp(struct npcm750_vcd *vcd)
+static int npcm750_vcd_get_bpp(struct npcm750_vcd *priv)
 {
-	u8 color_cnvr = ((npcm750_vcd_read(vcd, VCD_MODE)
-		& VCD_MODE_COLOR_CNVRT)
-		>> VCD_MODE_COLOR_CNVRT_OFFSET);
+	struct regmap *vcd = priv->vcd_regmap;
+	u32 mode, color_cnvr;
+
+	regmap_read(vcd, VCD_MODE, &mode);
+
+	color_cnvr = (mode & VCD_MODE_COLOR_CNVRT) >>
+		VCD_MODE_COLOR_CNVRT_OFFSET;
 
 	switch (color_cnvr) {
 	case VCD_MODE_COLOR_NORM:
@@ -501,8 +539,9 @@ static int npcm750_vcd_get_bpp(struct npcm750_vcd *vcd)
 	return 0;
 }
 
-static void npcm750_vcd_set_linepitch(struct npcm750_vcd *vcd, u32 linebytes)
+static void npcm750_vcd_set_linepitch(struct npcm750_vcd *priv, u32 linebytes)
 {
+	struct regmap *vcd = priv->vcd_regmap;
 	/* Pitch must be a power of 2, >= linebytes,*/
 	/* at least 512, and no more than 4096. */
 	u32 pitch = VCD_MIN_LP;
@@ -510,30 +549,41 @@ static void npcm750_vcd_set_linepitch(struct npcm750_vcd *vcd, u32 linebytes)
 	while ((pitch < linebytes) && (pitch < VCD_MAX_LP))
 		pitch *= 2;
 
-	npcm750_vcd_write(vcd, VCD_FB_LP, (pitch << VCD_FBB_LP_OFFSET) | pitch);
+	regmap_write(vcd, VCD_FB_LP, (pitch << VCD_FBB_LP_OFFSET) | pitch);
 }
 
-static u32 npcm750_vcd_get_linepitch(struct npcm750_vcd *vcd)
+static u32 npcm750_vcd_get_linepitch(struct npcm750_vcd *priv)
 {
-	return npcm750_vcd_read(vcd, VCD_FB_LP) & VCD_FB_LP_MASK;
+	struct regmap *vcd = priv->vcd_regmap;
+	u32 linepitch;
+
+	regmap_read(vcd, VCD_FB_LP, &linepitch);
+
+	return linepitch & VCD_FB_LP_MASK;
 }
 
-static int npcm750_vcd_ready(struct npcm750_vcd *vcd)
+static int npcm750_vcd_ready(struct npcm750_vcd *priv)
 {
-	npcm750_vcd_write(vcd, VCD_FB_LP, 0xffffffff);
-	npcm750_vcd_write(vcd, VCD_CAP_RES, 0xffffffff);
+	struct regmap *vcd = priv->vcd_regmap;
+	u32 lp, res;
+
+	regmap_write(vcd, VCD_FB_LP, 0xffffffff);
+	regmap_write(vcd, VCD_CAP_RES, 0xffffffff);
+
+	regmap_read(vcd, VCD_FB_LP, &lp);
+	regmap_read(vcd, VCD_CAP_RES, &res);
 
-	if ((npcm750_vcd_read(vcd, VCD_FB_LP) != 0xfe00fe00) ||
-	    (npcm750_vcd_read(vcd, VCD_CAP_RES) != 0x7ff07ff)) {
-		dev_err(vcd->dev, "vcd hw is not ready\n");
+	if ((lp != 0xfe00fe00) || (res != 0x7ff07ff)) {
+		dev_err(priv->dev, "vcd hw is not ready\n");
 		return -ENODEV;
 	}
+
 	return 0;
 }
 
-static u32 npcm750_vcd_pclk(struct npcm750_vcd *vcd)
+static u32 npcm750_vcd_pclk(struct npcm750_vcd *priv)
 {
-	struct regmap *gfxi = vcd->gfx_regmap;
+	struct regmap *gfxi = priv->gfx_regmap;
 	u32 tmp, pllfbdiv, pllinotdiv, gpllfbdiv;
 	u8 gpllfbdv109, gpllfbdv8, gpllindiv;
 	u8 gpllst_pllotdiv1, gpllst_pllotdiv2;
@@ -560,49 +610,57 @@ static u32 npcm750_vcd_pclk(struct npcm750_vcd *vcd)
 }
 
 static int
-npcm750_vcd_capres(struct npcm750_vcd *vcd, u32 width, u32 height)
+npcm750_vcd_capres(struct npcm750_vcd *priv, u32 width, u32 height)
 {
+	struct regmap *vcd = priv->vcd_regmap;
 	u32 res = (height & VCD_CAPRES_MASK)
 		| ((width & VCD_CAPRES_MASK) << 16);
+	u32 cap_res;
 
 	if ((width > VCD_MAX_WIDTH) || (height > VCD_MAX_HIGHT))
 		return -EINVAL;
 
-	npcm750_vcd_write(vcd, VCD_CAP_RES, res);
+	regmap_write(vcd, VCD_CAP_RES, res);
+	regmap_read(vcd, VCD_CAP_RES, &cap_res);
 
 	/* Read back the register to check that the values were valid */
-	if (npcm750_vcd_read(vcd, VCD_CAP_RES) !=  res)
+	if (cap_res !=  res)
 		return -EINVAL;
 
 	return 0;
 }
 static void
-npcm750_short_vcd_reset(struct npcm750_vcd *vcd)
+npcm750_short_vcd_reset(struct npcm750_vcd *priv)
 {
-	npcm750_vcd_write(vcd, VCD_INTE, 0);
-	npcm750_vcd_update(vcd, VCD_CMD, VCD_CMD_RST, VCD_CMD_RST);
+	struct regmap *vcd = priv->vcd_regmap;
+	u32 stat;
+
+	regmap_write(vcd, VCD_INTE, 0);
 
-	while (!(npcm750_vcd_read(vcd, VCD_STAT) & VCD_STAT_DONE))
+	regmap_update_bits(vcd, VCD_CMD, VCD_CMD_RST, VCD_CMD_RST);
+	while (!regmap_read(vcd, VCD_STAT, &stat) & !(stat & VCD_STAT_DONE))
 		continue;
 
-	npcm750_vcd_write(vcd, VCD_STAT,0xffffffff);
-	npcm750_vcd_write(vcd, VCD_INTE, VCD_INTE_VAL);
+	regmap_write(vcd, VCD_STAT, VCD_STAT_CLEAR);
+	regmap_write(vcd, VCD_INTE, VCD_INTE_VAL);
 }
 
-static int npcm750_vcd_reset(struct npcm750_vcd *vcd)
+static int npcm750_vcd_reset(struct npcm750_vcd *priv)
 {
-	struct regmap *gcr = vcd->gcr_regmap;
+	struct regmap *gcr = priv->gcr_regmap;
+	struct regmap *vcd = priv->vcd_regmap;
+	u32 stat;
 
-	npcm750_vcd_update(vcd, VCD_CMD, VCD_CMD_RST, VCD_CMD_RST);
+	regmap_update_bits(vcd, VCD_CMD, VCD_CMD_RST, VCD_CMD_RST);
 
-	while (!(npcm750_vcd_read(vcd, VCD_STAT) & VCD_STAT_DONE))
+	while (!regmap_read(vcd, VCD_STAT, &stat) & !(stat & VCD_STAT_DONE))
 		continue;
 
 	/* Active graphic reset */
 	regmap_update_bits(
 		gcr, INTCR2, INTCR2_GIRST2, INTCR2_GIRST2);
 
-	npcm750_vcd_write(vcd, VCD_STAT, VCD_STAT_CLEAR);
+	regmap_write(vcd, VCD_STAT, VCD_STAT_CLEAR);
 
 	/* Inactive graphic reset */
 	regmap_update_bits(
@@ -611,153 +669,185 @@ static int npcm750_vcd_reset(struct npcm750_vcd *vcd)
 	return 0;
 }
 
-static void npcm750_vcd_io_reset(struct npcm750_vcd *vcd)
+static void npcm750_vcd_io_reset(struct npcm750_vcd *priv)
 {
-	npcm750_vcd_write(vcd, VCD_INTE, 0);
-	npcm750_vcd_write(vcd, VCD_STAT, VCD_STAT_CLEAR);
-	npcm750_vcd_reset(vcd);
-	npcm750_vcd_write(vcd, VCD_INTE, VCD_INTE_VAL);
+	struct regmap *vcd = priv->vcd_regmap;
+
+	regmap_write(vcd, VCD_INTE, 0);
+	regmap_write(vcd, VCD_STAT, VCD_STAT_CLEAR);
+	npcm750_vcd_reset(priv);
+	regmap_write(vcd, VCD_INTE, VCD_INTE_VAL);
 }
 
-static void npcm750_vcd_dehs(struct npcm750_vcd *vcd, int is_de)
+static void npcm750_vcd_dehs(struct npcm750_vcd *priv, int is_de)
 {
-	struct regmap *gcr = vcd->gcr_regmap;
+	struct regmap *gcr = priv->gcr_regmap;
+	struct regmap *vcd = priv->vcd_regmap;
 
 	if (is_de) {
-		npcm750_vcd_update(
+		regmap_update_bits(
 			vcd, VCD_MODE, VCD_MODE_DE_HS, ~VCD_MODE_DE_HS);
 		regmap_update_bits(
 			gcr, INTCR, INTCR_DEHS, ~INTCR_DEHS);
 	} else {
-		npcm750_vcd_update(
+		regmap_update_bits(
 			vcd, VCD_MODE, VCD_MODE_DE_HS, VCD_MODE_DE_HS);
 		regmap_update_bits(
 			gcr, INTCR, INTCR_DEHS, INTCR_DEHS);
 	}
 }
 
-static void npcm750_vcd_kvm_bw(struct npcm750_vcd *vcd, u8 bandwidth)
+static void npcm750_vcd_kvm_bw(struct npcm750_vcd *priv, u8 bandwidth)
 {
-	if (!npcm750_vcd_is_mga(vcd))
+	struct regmap *vcd = priv->vcd_regmap;
+
+	if (!npcm750_vcd_is_mga(priv))
 		bandwidth = 1;
 
 	if (bandwidth)
-		npcm750_vcd_update(
+		regmap_update_bits(
 			vcd,
 			VCD_MODE,
 			VCD_MODE_KVM_BW_SET,
 			VCD_MODE_KVM_BW_SET);
 	else
-		npcm750_vcd_update(
+		regmap_update_bits(
 			vcd,
 			VCD_MODE,
 			VCD_MODE_KVM_BW_SET,
 			~VCD_MODE_KVM_BW_SET);
 }
 
-static void npcm750_vcd_detect_video_mode(struct npcm750_vcd *vcd)
+static void npcm750_vcd_update_info(struct npcm750_vcd *priv)
+{
+	struct regmap *vcd = priv->vcd_regmap;
+
+	priv->info.hdisp = npcm750_vcd_hres(priv);
+	priv->info.vdisp = npcm750_vcd_vres(priv);
+	priv->video_name = "Digital";
+	priv->info.pixelclk = npcm750_vcd_pclk(priv);
+	priv->info.bpp = npcm750_vcd_get_bpp(priv);
+	priv->info.mode = npcm750_vcd_is_mga(priv);
+	priv->info.refresh_rate = 60;
+	priv->info.hfrontporch = 0;
+	priv->info.hbackporch = 0;
+	priv->info.vfrontporch = 0;
+	priv->info.vbackporch = 0;
+	priv->info.hpositive = 1;
+	priv->info.vpositive = 0;
+
+	if (priv->info.hdisp > VCD_MAX_WIDTH)
+		priv->info.hdisp = VCD_MAX_WIDTH;
+
+	if (priv->info.vdisp > VCD_MAX_HIGHT)
+		priv->info.vdisp = VCD_MAX_HIGHT;
+
+	regmap_read(vcd, VCD_HOR_AC_TIM, &priv->hortact);
+	priv->hortact &= VCD_HOR_AC_TIM_MASK;
+
+}
+
+static void npcm750_vcd_detect_video_mode(struct npcm750_vcd *priv)
 {
-	vcd->info.hdisp = npcm750_vcd_hres(vcd);
-	vcd->info.vdisp = npcm750_vcd_vres(vcd);
-	vcd->video_name = "Digital";
-	vcd->info.pixelclk = npcm750_vcd_pclk(vcd);
-	vcd->info.bpp = npcm750_vcd_get_bpp(vcd);
-	vcd->info.mode = npcm750_vcd_is_mga(vcd);
-	vcd->info.refresh_rate = 60;
-	vcd->info.hfrontporch = 0;
-	vcd->info.hbackporch = 0;
-	vcd->info.vfrontporch = 0;
-	vcd->info.vbackporch = 0;
-	vcd->info.hpositive = 1;
-	vcd->info.vpositive = 0;
-
-	if (vcd->info.hdisp > VCD_MAX_WIDTH)
-		vcd->info.hdisp = VCD_MAX_WIDTH;
-
-	if (vcd->info.vdisp > VCD_MAX_HIGHT)
-		vcd->info.vdisp = VCD_MAX_HIGHT;
-
-	vcd->hortact = ((npcm750_vcd_read(vcd,VCD_HOR_AC_TIM)) &
-		(VCD_HOR_AC_TIM_MASK));
-
-	npcm750_vcd_capres(vcd, vcd->info.hdisp, vcd->info.vdisp);
+	struct regmap *vcd = priv->vcd_regmap;
+	u32 mode;
+
+	npcm750_vcd_capres(priv, priv->info.hdisp, priv->info.vdisp);
 
 	npcm750_vcd_set_linepitch(
-		vcd, vcd->info.hdisp * npcm750_vcd_get_bpp(vcd));
-	vcd->info.line_pitch = npcm750_vcd_get_linepitch(vcd);
-	npcm750_vcd_kvm_bw(vcd, vcd->info.pixelclk > VCD_KVM_BW_PCLK);
+		priv, priv->info.hdisp * npcm750_vcd_get_bpp(priv));
+
+	priv->info.line_pitch = npcm750_vcd_get_linepitch(priv);
+
+	npcm750_vcd_kvm_bw(priv, priv->info.pixelclk > VCD_KVM_BW_PCLK);
 
-	npcm750_vcd_reset(vcd);
+	npcm750_vcd_reset(priv);
 
-	dev_dbg(vcd->dev, "VCD Mode = 0x%x, %s mode\n",
-		(u32)npcm750_vcd_read(vcd, VCD_MODE),
-		npcm750_vcd_is_mga(vcd) ? "Hi Res" : "VGA");
+	regmap_read(vcd, VCD_MODE, &mode);
 
-	dev_dbg(vcd->dev, "Resolution: %d x %d, Pixel Clk %zuKHz, Line Pitch %d\n",
-			vcd->info.hdisp, vcd->info.vdisp,
-			vcd->info.pixelclk,
-			vcd->info.line_pitch);
+	dev_dbg(priv->dev, "VCD Mode = 0x%x, %s mode\n", mode,
+		npcm750_vcd_is_mga(priv) ? "Hi Res" : "VGA");
+
+	dev_dbg(priv->dev, "Resolution: %d x %d, Pixel Clk %zuKHz, Line Pitch %d\n",
+			priv->info.hdisp, priv->info.vdisp,
+			priv->info.pixelclk,
+			priv->info.line_pitch);
 }
 
-static u8 npcm750_vcd_is_busy(struct npcm750_vcd *vcd)
+static u8 npcm750_vcd_is_busy(struct npcm750_vcd *priv)
 {
-	return ((npcm750_vcd_read(
-		vcd, VCD_STAT) & VCD_STAT_BUSY) == VCD_STAT_BUSY);
+	struct regmap *vcd = priv->vcd_regmap;
+	u32 stat;
+
+	regmap_read(vcd, VCD_STAT, &stat);
+	stat &= VCD_STAT_BUSY;
+
+	return (stat == VCD_STAT_BUSY);
 }
 
-static u8 npcm750_vcd_op_done(struct npcm750_vcd *vcd)
+static u8 npcm750_vcd_op_done(struct npcm750_vcd *priv)
 {
-	u32 vdisp = npcm750_vcd_read(vcd, VCD_CAP_RES) & VCD_CAPRES_MASK;
-	u32 curline = ((vcd->status & VCD_STAT_CURR_LINE)
+	struct regmap *vcd = priv->vcd_regmap;
+	u32 vdisp;
+	u32 curline = ((priv->status & VCD_STAT_CURR_LINE)
 		>> VCD_STAT_CURR_LINE_OFFSET);
 
-	return ((vcd->status & VCD_STAT_DONE) &&
-		!(vcd->status & VCD_STAT_BUSY) &&
+	regmap_read(vcd, VCD_CAP_RES, &vdisp);
+	vdisp &= VCD_CAPRES_MASK;
+
+	return ((priv->status & VCD_STAT_DONE) &&
+		!(priv->status & VCD_STAT_BUSY) &&
 		(curline == vdisp));
 }
 
-static int npcm750_vcd_command(struct npcm750_vcd *vcd, u32 value)
+static int npcm750_vcd_command(struct npcm750_vcd *priv, u32 value)
 {
+	struct regmap *vcd = priv->vcd_regmap;
 	u32 cmd;
 
-	if (npcm750_vcd_is_busy(vcd))
+	if (npcm750_vcd_is_busy(priv))
 		/* Not ready for another command */
 		return -EBUSY;
 
 	/* Clear the status flags that could be set by this command */
-	npcm750_vcd_write(vcd, VCD_STAT, 0xFFFFFFFF);
+	regmap_write(vcd, VCD_STAT, VCD_STAT_CLEAR);
 
-	cmd = npcm750_vcd_read(vcd, VCD_CMD) & ~VCD_CMD_OP_MASK;
+	regmap_read(vcd, VCD_CMD, &cmd);
+
+	cmd &= ~VCD_CMD_OP_MASK;
 	cmd |= (value << VCD_CMD_OP_OFFSET);
 
-	npcm750_vcd_write(vcd, VCD_CMD, cmd);
-	npcm750_vcd_write(vcd, VCD_CMD, cmd | VCD_CMD_GO);
-	vcd->cmd = value;
+	regmap_write(vcd, VCD_CMD, cmd);
+	regmap_write(vcd, VCD_CMD, cmd | VCD_CMD_GO);
+	priv->cmd = value;
 
 	return 0;
 }
 
-static int npcm750_vcd_get_resolution(struct npcm750_vcd *vcd)
+static int npcm750_vcd_get_resolution(struct npcm750_vcd *priv)
 {
-	int i;
-	u8 res_retry = 3;
-	u8 vaild_retry = 3;
+	struct regmap *vcd = priv->vcd_regmap;
+	size_t i;
+	u32 res_retry = GET_RES_RERTY;
+	u32 vaild_retry = GET_RES_VALID_RERTY;
+	u32 hortact;
 	u8 vaild = 0;
-	u32 hortact = (npcm750_vcd_read(vcd,VCD_HOR_AC_TIM)
-		& VCD_HOR_AC_TIM_MASK);
+
+	regmap_read(vcd, VCD_HOR_AC_TIM, &hortact);
+	hortact &= VCD_HOR_AC_TIM_MASK;
 
 	/* check with GFX registers if resolution changed from last time */
-	if ((vcd->info.hdisp != npcm750_vcd_hres(vcd)) ||
-		(vcd->info.vdisp != npcm750_vcd_vres(vcd)) ||
-		(vcd->info.pixelclk != npcm750_vcd_pclk(vcd)) ||
-		(vcd->info.mode != npcm750_vcd_is_mga(vcd)) ||
-		(vcd->hortact != hortact)) {
+	if ((priv->info.hdisp != npcm750_vcd_hres(priv)) ||
+		(priv->info.vdisp != npcm750_vcd_vres(priv)) ||
+		(priv->info.pixelclk != npcm750_vcd_pclk(priv)) ||
+		(priv->info.mode != npcm750_vcd_is_mga(priv)) ||
+		(priv->hortact != hortact)) {
 
-		npcm750_vcd_write(vcd, VCD_INTE, 0);
-		npcm750_vcd_write(vcd, VCD_STAT, VCD_STAT_CLEAR);
+		regmap_write(vcd, VCD_INTE, 0);
+		regmap_write(vcd, VCD_STAT, VCD_STAT_CLEAR);
 
-		if (npcm750_vcd_hres(vcd) && npcm750_vcd_vres(vcd)) {
-			struct regmap *gfxi = vcd->gfx_regmap;
+		if (npcm750_vcd_hres(priv) && npcm750_vcd_vres(priv)) {
+			struct regmap *gfxi = priv->gfx_regmap;
 			u32 dispst;
 
 			/* wait for resolution is available,
@@ -765,19 +855,19 @@ static int npcm750_vcd_get_resolution(struct npcm750_vcd *vcd)
 			do {
 				if (res_retry == 0)
 					return -1;
-				mdelay(300);
+				mdelay(GET_RES_TIMEOUT);
 				regmap_read(gfxi, DISPST, &dispst);
 				res_retry--;
-			} while (npcm750_vcd_vres(vcd) < 100 ||
-					npcm750_vcd_pclk(vcd) == 0 ||
+			} while (npcm750_vcd_vres(priv) < 100 ||
+					npcm750_vcd_pclk(priv) == 0 ||
 					(dispst & DISPST_HSCROFF));
 		}
 
 		/* wait for valid resolution */
 		while (vaild_retry--) {
 			for (i = 0 ; i < restlb_cnt ; i++) {
-				if ((res_tlbs[i].hdisp == npcm750_vcd_hres(vcd)) &&
-					(res_tlbs[i].vdisp == npcm750_vcd_vres(vcd))) {
+				if ((res_tlbs[i].hdisp == npcm750_vcd_hres(priv)) &&
+					(res_tlbs[i].vdisp == npcm750_vcd_vres(priv))) {
 					vaild = 1;
 					break;
 				}
@@ -785,34 +875,39 @@ static int npcm750_vcd_get_resolution(struct npcm750_vcd *vcd)
 			if (vaild)
 				break;
 			else
-				mdelay(100);
+				mdelay(GET_RES_VALID_TIMEOUT);
 		}
 
+		/* Update video information */
+		npcm750_vcd_update_info(priv);
+
 		if (!vaild) {
-			dev_err(vcd->dev, "invalid resolution %d x %d\n",
-				npcm750_vcd_hres(vcd), npcm750_vcd_vres(vcd));
+			dev_info(priv->dev, "invalid resolution %d x %d\n",
+				npcm750_vcd_hres(priv), npcm750_vcd_vres(priv));
+			if (npcm750_vcd_vres(priv) == 0)
+				npcm750_vcd_claer_gmmap(priv);
 			return -1;
 		}
 
 		/* setup resolution change detect register*/
-		npcm750_vcd_detect_video_mode(vcd);
+		npcm750_vcd_detect_video_mode(priv);
 
 		/* enable interrupt */
-		npcm750_vcd_write(vcd, VCD_INTE, VCD_INTE_VAL);
+		regmap_write(vcd, VCD_INTE, VCD_INTE_VAL);
 
 		return 1;
 	}
 	return 0;
 }
 
-static void npcm750_vcd_free_diff_table(struct npcm750_vcd *vcd)
+static void npcm750_vcd_free_diff_table(struct npcm750_vcd *priv)
 {
 	struct list_head *head, *pos, *nx;
 	struct rect_list *tmp;
 
-	vcd->rect_cnt = 0;
+	priv->rect_cnt = 0;
 
-	head = &vcd->list;
+	head = &priv->list;
 	list_for_each_safe(pos, nx, head) {
 		tmp = list_entry(pos, struct rect_list, list);
 		if (tmp) {
@@ -823,7 +918,7 @@ static void npcm750_vcd_free_diff_table(struct npcm750_vcd *vcd)
 }
 
 static void
-npcm750_vcd_merge_rect(struct npcm750_vcd *vcd, struct rect_info *info)
+npcm750_vcd_merge_rect(struct npcm750_vcd *priv, struct rect_info *info)
 {
 	struct list_head *head = info->head;
 	struct rect_list *list = info->list;
@@ -833,7 +928,7 @@ npcm750_vcd_merge_rect(struct npcm750_vcd *vcd, struct rect_info *info)
 		first = list;
 		info->first = first;
 		list_add_tail(&list->list, head);
-		vcd->rect_cnt++;
+		priv->rect_cnt++;
 	} else {
 		if (((list->r.x ==
 		      (first->r.x + first->r.w))) &&
@@ -852,14 +947,14 @@ npcm750_vcd_merge_rect(struct npcm750_vcd *vcd, struct rect_info *info)
 			kfree(list);
 		} else {
 			list_add_tail(&list->list, head);
-			vcd->rect_cnt++;
+			priv->rect_cnt++;
 			info->first = list;
 		}
 	}
 }
 
 static struct rect_list *
-npcm750_vcd_new_rect(struct npcm750_vcd *vcd, int offset, int index)
+npcm750_vcd_new_rect(struct npcm750_vcd *priv, int offset, int index)
 {
 	struct rect_list *list = NULL;
 
@@ -871,43 +966,44 @@ npcm750_vcd_new_rect(struct npcm750_vcd *vcd, int offset, int index)
 	list->r.y = (index >> 2);
 	list->r.w = RECT_TILE_W;
 	list->r.h = RECT_TILE_H;
-	if ((list->r.x + RECT_TILE_W) > vcd->info.hdisp)
-		list->r.w = vcd->info.hdisp - list->r.x;
-	if ((list->r.y + RECT_TILE_H) > vcd->info.vdisp)
-		list->r.h = vcd->info.vdisp - list->r.y;
+	if ((list->r.x + RECT_TILE_W) > priv->info.hdisp)
+		list->r.w = priv->info.hdisp - list->r.x;
+	if ((list->r.y + RECT_TILE_H) > priv->info.vdisp)
+		list->r.h = priv->info.vdisp - list->r.y;
 
 	return list;
 }
 
 static int
-npcm750_vcd_rect(struct npcm750_vcd *vcd, struct rect_info *info, u32 offset)
+npcm750_vcd_rect(struct npcm750_vcd *priv, struct rect_info *info, u32 offset)
 {
 	int i = info->index;
 
 	if (offset < info->tile_perline) {
-		info->list = npcm750_vcd_new_rect(vcd, offset, i);
+		info->list = npcm750_vcd_new_rect(priv, offset, i);
 		if (!info->list)
 			return -ENOMEM;
 
-		npcm750_vcd_merge_rect(vcd, info);
+		npcm750_vcd_merge_rect(priv, info);
 	}
 	return 0;
 }
 
 static int
-npcm750_vcd_build_table(struct npcm750_vcd *vcd, struct rect_info *info)
+npcm750_vcd_build_table(struct npcm750_vcd *priv, struct rect_info *info)
 {
 	int i = info->index;
 	int j, z, ret;
+	u32 bitmap;
+	struct regmap *vcd = priv->vcd_regmap;
 
 	for (j = 0 ; j < info->offset_perline ; j += 4) {
-		if (npcm750_vcd_read(vcd, VCD_DIFF_TBL + (j + i)) != 0) {
+		regmap_read(vcd, VCD_DIFF_TBL + (j + i), &bitmap);
+		if (bitmap != 0) {
 			for (z = 0 ; z < 32; z++) {
-				if ((npcm750_vcd_read(
-					vcd,
-					VCD_DIFF_TBL + (j + i)) >> z) & 0x01) {
+				if ((bitmap >> z) & 0x01) {
 					ret = npcm750_vcd_rect(
-							vcd,
+							priv,
 							info,
 							z + (j << 3));
 					if (ret < 0)
@@ -920,22 +1016,22 @@ npcm750_vcd_build_table(struct npcm750_vcd *vcd, struct rect_info *info)
 	return info->tile_perline;
 }
 
-static int npcm750_vcd_get_diff_table(struct npcm750_vcd *vcd)
+static int npcm750_vcd_get_diff_table(struct npcm750_vcd *priv)
 {
 	struct rect_info info;
 	int ret = 0;
 	u32 mod, tile_cnt = 0;
 
 	memset(&info, 0, sizeof(struct rect_info));
-	info.head = &vcd->list;
+	info.head = &priv->list;
 
-	info.tile_perline = vcd->info.hdisp >> 4;
-	mod = vcd->info.hdisp % RECT_TILE_W;
+	info.tile_perline = priv->info.hdisp >> 4;
+	mod = priv->info.hdisp % RECT_TILE_W;
 	if (mod != 0)
 		info.tile_perline += 1;
 
-	info.tile_perrow = vcd->info.vdisp >> 4;
-	mod = vcd->info.vdisp % RECT_TILE_H;
+	info.tile_perrow = priv->info.vdisp >> 4;
+	mod = priv->info.vdisp % RECT_TILE_H;
 	if (mod != 0)
 		info.tile_perrow += 1;
 
@@ -950,7 +1046,7 @@ static int npcm750_vcd_get_diff_table(struct npcm750_vcd *vcd)
 	info.offset_perline *= 4;
 
 	do {
-		ret = npcm750_vcd_build_table(vcd, &info);
+		ret = npcm750_vcd_build_table(priv, &info);
 		if (ret < 0)
 			return ret;
 		tile_cnt += ret;
@@ -959,9 +1055,10 @@ static int npcm750_vcd_get_diff_table(struct npcm750_vcd *vcd)
 	return ret;
 }
 
-static int npcm750_vcd_init(struct npcm750_vcd *vcd)
+static int npcm750_vcd_init(struct npcm750_vcd *priv)
 {
-	struct regmap *gcr = vcd->gcr_regmap;
+	struct regmap *gcr = priv->gcr_regmap;
+	struct regmap *vcd = priv->vcd_regmap;
 
 	/* Enable display of KVM GFX and access to memory */
 	regmap_update_bits(gcr, INTCR, INTCR_GFXIFDIS, ~INTCR_GFXIFDIS);
@@ -977,64 +1074,68 @@ static int npcm750_vcd_init(struct npcm750_vcd *vcd)
 	/* Select KVM GFX input */
 	regmap_update_bits(gcr, MFSEL1, MFSEL1_DVH1SEL, ~MFSEL1_DVH1SEL);
 
-	if (npcm750_vcd_ready(vcd))
+	if (npcm750_vcd_ready(priv))
 		return	-ENODEV;
 
-	npcm750_vcd_reset(vcd);
+	npcm750_vcd_reset(priv);
 
 	/* Initialise capture resolution to a non-zero value */
 	/* so that frame capture will behave sensibly before */
 	/* the true resolution has been determined.*/
-	if (npcm750_vcd_capres(vcd, VCD_INIT_WIDTH, VCD_INIT_HIGHT)) {
-		dev_err(vcd->dev, "failed to set resolution\n");
+	if (npcm750_vcd_capres(priv, VCD_INIT_WIDTH, VCD_INIT_HIGHT)) {
+		dev_err(priv->dev, "failed to set resolution\n");
 		return -EINVAL;
 	}
 
 	/* Set the FIFO thresholds */
-	npcm750_vcd_write(vcd, VCD_FIFO, VCD_FIFO_TH);
+	regmap_write(vcd, VCD_FIFO, VCD_FIFO_TH);
 
 	/* Set vcd frame physical address */
-	npcm750_vcd_write(vcd, VCD_FBA_ADR, vcd->frame_start);
-	npcm750_vcd_write(vcd, VCD_FBB_ADR, vcd->frame_start);
+	regmap_write(vcd, VCD_FBA_ADR, priv->frame_start);
+	regmap_write(vcd, VCD_FBB_ADR, priv->frame_start);
 
 	/* Set vcd mode */
-	npcm750_vcd_update(vcd, VCD_MODE, 0xFFFFFFFF,
+	regmap_update_bits(vcd, VCD_MODE, 0xFFFFFFFF,
 			    VCD_MODE_CM_565 | VCD_MODE_KVM_BW_SET);
 
 	/* Set DVDE/DVHSYNC */
-	npcm750_vcd_dehs(vcd, vcd->de_mode);
+	npcm750_vcd_dehs(priv, priv->de_mode);
 
-	vcd->info.vcd_fb = vcd->frame_start;
-	vcd->info.r_max = VCD_R_MAX;
-	vcd->info.g_max = VCD_G_MAX;
-	vcd->info.b_max = VCD_B_MAX;
-	vcd->info.r_shift = VCD_R_SHIFT;
-	vcd->info.g_shift = VCD_G_SHIFT;
-	vcd->info.b_shift = VCD_B_SHIFT;
+	priv->info.vcd_fb = priv->frame_start;
+	priv->info.r_max = VCD_R_MAX;
+	priv->info.g_max = VCD_G_MAX;
+	priv->info.b_max = VCD_B_MAX;
+	priv->info.r_shift = VCD_R_SHIFT;
+	priv->info.g_shift = VCD_G_SHIFT;
+	priv->info.b_shift = VCD_B_SHIFT;
 
 	/* Enable local disaply */
-	npcm750_vcd_local_display(vcd, 1);
+	npcm750_vcd_local_display(priv, 1);
+
+	/* Update video information */
+	npcm750_vcd_update_info(priv);
 
 	/* Detect video mode */
-	npcm750_vcd_detect_video_mode(vcd);
+	npcm750_vcd_detect_video_mode(priv);
 
 	/* Enable interrupt */
-	npcm750_vcd_write(vcd, VCD_INTE, VCD_INTE_VAL);
+	regmap_write(vcd, VCD_INTE, VCD_INTE_VAL);
 
-	if (!vcd->de_mode) {
-		npcm750_vcd_update(vcd, VCD_RCHG, VCD_RCHG_TIM_PRSCL,
+	if (!priv->de_mode) {
+		regmap_update_bits(vcd, VCD_RCHG, VCD_RCHG_TIM_PRSCL,
 			0x01 << VCD_RCHG_TIM_PRSCL_OFFSET);
 	} else {
-		npcm750_vcd_dvod(vcd, 0, 0);
-		npcm750_vcd_write(vcd, VCD_RCHG, 0);
+		npcm750_vcd_dvod(priv, 0, 0);
+		regmap_write(vcd, VCD_RCHG, 0);
 	}
 
 	return 0;
 }
 
-static void npcm750_vcd_stop(struct npcm750_vcd *vcd)
+static void npcm750_vcd_stop(struct npcm750_vcd *priv)
 {
-	struct regmap *gcr = vcd->gcr_regmap;
+	struct regmap *gcr = priv->gcr_regmap;
+	struct regmap *vcd = priv->vcd_regmap;
 
 	/* Disable display of KVM GFX and access to memory */
 	regmap_update_bits(gcr, INTCR, INTCR_GFXIFDIS, INTCR_GFXIFDIS);
@@ -1042,105 +1143,106 @@ static void npcm750_vcd_stop(struct npcm750_vcd *vcd)
 	/* KVM is not in progress */
 	regmap_update_bits(gcr, INTCR, INTCR_KVMSI, ~INTCR_KVMSI);
 
-	npcm750_vcd_write(vcd, VCD_INTE, 0);
-	npcm750_vcd_write(vcd, VCD_STAT, VCD_STAT_CLEAR);
-	npcm750_vcd_write(vcd, VCD_MODE, 0);
-	npcm750_vcd_write(vcd, VCD_RCHG, 0);
+	regmap_write(vcd, VCD_INTE, 0);
+	regmap_write(vcd, VCD_STAT, VCD_STAT_CLEAR);
+	regmap_write(vcd, VCD_MODE, 0);
+	regmap_write(vcd, VCD_RCHG, 0);
 
-	npcm750_vcd_free_diff_table(vcd);
-	memset(&vcd->info, 0, sizeof(struct vcd_info));
+	npcm750_vcd_free_diff_table(priv);
+	memset(&priv->info, 0, sizeof(struct vcd_info));
 }
 
 static irqreturn_t npcm750_vcd_irq_handler(int irq, void *dev_instance)
 {
 	struct device *dev = dev_instance;
-	struct npcm750_vcd *vcd = (struct npcm750_vcd *)dev->driver_data;
+	struct npcm750_vcd *priv = (struct npcm750_vcd *)dev->driver_data;
+	struct regmap *vcd = priv->vcd_regmap;
 	u32 status;
 	u32 status_ack = 0;
 
-	spin_lock(&vcd->lock);
+	spin_lock(&priv->lock);
 
-	status = npcm750_vcd_read(vcd, VCD_STAT);
+	regmap_read(vcd, VCD_STAT, &status);
 	if (status & VCD_STAT_IRQ) {
 		if (status & VCD_STAT_DONE) {
-			dev_dbg(vcd->dev, "VCD_STAT_DONE\n");
+			dev_dbg(priv->dev, "VCD_STAT_DONE\n");
 			status_ack |= VCD_STAT_DONE;
 		}
 
 		if (status & VCD_STAT_HSYNC) {
-			dev_dbg(vcd->dev, "VCD_STAT_HSYNC\n");
+			dev_dbg(priv->dev, "VCD_STAT_HSYNC\n");
 			status_ack |= VCD_STAT_HSYNC;
 		}
 
 		if (status & VCD_STAT_VSYNC) {
-			dev_dbg(vcd->dev, "VCD_STAT_VSYNC\n");
+			dev_dbg(priv->dev, "VCD_STAT_VSYNC\n");
 			status_ack |= VCD_STAT_VSYNC;
 		}
 
 		if (status & VCD_STAT_HAC_CHG) {
-			dev_dbg(vcd->dev, "VCD_STAT_HAC_CHG\n");
+			dev_dbg(priv->dev, "VCD_STAT_HAC_CHG\n");
 			status_ack |= VCD_STAT_HAC_CHG;
 		}
 
 		if (status & VCD_STAT_HLC_CHG) {
-			dev_dbg(vcd->dev, "VCD_STAT_HLC_CHG\n");
+			dev_dbg(priv->dev, "VCD_STAT_HLC_CHG\n");
 			status_ack |= VCD_STAT_HLC_CHG;
 		}
 
 		if (status & VCD_STAT_HHT_CHG) {
-			dev_dbg(vcd->dev, "VCD_STAT_HHT_CHG\n");
+			dev_dbg(priv->dev, "VCD_STAT_HHT_CHG\n");
 			status_ack |= VCD_STAT_HHT_CHG;
 		}
 
 		if (status & VCD_STAT_HCT_CHG) {
-			dev_dbg(vcd->dev, "VCD_STAT_HCT_CHG\n");
+			dev_dbg(priv->dev, "VCD_STAT_HCT_CHG\n");
 			status_ack |= VCD_STAT_HCT_CHG;
 		}
 
 		if (status & VCD_STAT_VHT_CHG) {
-			dev_dbg(vcd->dev, "VCD_STAT_VHT_CHG\n");
+			dev_dbg(priv->dev, "VCD_STAT_VHT_CHG\n");
 			status_ack |= VCD_STAT_VHT_CHG;
 		}
 
 		if (status & VCD_STAT_VCT_CHG) {
-			dev_dbg(vcd->dev, "VCD_STAT_VCT_CHG\n");
+			dev_dbg(priv->dev, "VCD_STAT_VCT_CHG\n");
 			status_ack |= VCD_STAT_VCT_CHG;
 		}
 
 		if (status & VCD_STAT_BSD1) {
-			dev_dbg(vcd->dev, "VCD_STAT_BSD1\n");
+			dev_dbg(priv->dev, "VCD_STAT_BSD1\n");
 			status_ack |= VCD_STAT_BSD1;
 		}
 
 		if (status & VCD_STAT_BSD2) {
-			dev_dbg(vcd->dev, "VCD_STAT_BSD2\n");
+			dev_dbg(priv->dev, "VCD_STAT_BSD2\n");
 			status_ack |= VCD_STAT_BSD2;
 		}
 
 		if (status & VCD_STAT_BSD3) {
-			dev_dbg(vcd->dev, "VCD_STAT_BSD3\n");
+			dev_dbg(priv->dev, "VCD_STAT_BSD3\n");
 			status_ack |= VCD_STAT_BSD3;
 		}
 
 		if (status & VCD_STAT_IFOT) {
-			dev_dbg(vcd->dev, "VCD_STAT_IFOT\n");
+			dev_dbg(priv->dev, "VCD_STAT_IFOT\n");
 			status_ack |= VCD_STAT_IFOT;
 		}
 
 		if (status & VCD_STAT_IFOR) {
-			dev_dbg(vcd->dev, "VCD_STAT_IFOR\n");
+			dev_dbg(priv->dev, "VCD_STAT_IFOR\n");
 			status_ack |= VCD_STAT_IFOR;
 		}
 
 	}
 
-	npcm750_vcd_write(vcd, VCD_STAT, status_ack);
+	regmap_write(vcd, VCD_STAT, status_ack);
 
-	vcd->status = status;
+	priv->status = status;
 
-	spin_unlock(&vcd->lock);
+	spin_unlock(&priv->lock);
 
-	complete(&vcd->complete);
+	complete(&priv->complete);
 
 	return IRQ_HANDLED;
 }
@@ -1148,15 +1250,15 @@ static irqreturn_t npcm750_vcd_irq_handler(int irq, void *dev_instance)
 static int
 npcm750_vcd_mmap(struct file *file, struct vm_area_struct *vma)
 {
-	struct npcm750_vcd *vcd = file->private_data;
+	struct npcm750_vcd *priv = file->private_data;
 	u32 start;
 	u32 len;
 
-	if (!vcd)
+	if (!priv)
 		return -ENODEV;
 
-	start = vcd->frame_start;
-	len = vcd->frame_len;
+	start = priv->frame_start;
+	len = priv->frame_len;
 	vma->vm_page_prot = vm_get_page_prot(vma->vm_flags);
 	fb_pgprotect(file, vma, start);
 
@@ -1166,49 +1268,50 @@ npcm750_vcd_mmap(struct file *file, struct vm_area_struct *vma)
 static int
 npcm750_vcd_open(struct inode *inode, struct file *file)
 {
-	struct npcm750_vcd *vcd =
+	struct npcm750_vcd *priv =
 		container_of(inode->i_cdev, struct npcm750_vcd, dev_cdev);
 
-	if (!vcd)
+	if (!priv)
 		return -ENODEV;
 
-	file->private_data = vcd;
+	file->private_data = priv;
 
-	if (atomic_inc_return(&vcd->clients) == 1) {
-		if (npcm750_vcd_init(vcd)) {
-			dev_err(vcd->dev, "%s: failed to init vcd module\n",
+	if (atomic_inc_return(&priv->clients) == 1) {
+		if (npcm750_vcd_init(priv)) {
+			dev_err(priv->dev, "%s: failed to init vcd module\n",
 				__func__);
 			return -EBUSY;
 		}
 	}
 
-	dev_dbg(vcd->dev, "open: client %d\n", atomic_read(&vcd->clients));
+	dev_dbg(priv->dev, "open: client %d\n", atomic_read(&priv->clients));
 	return 0;
 }
 
 static int
 npcm750_vcd_release(struct inode *inode, struct file *file)
 {
-	struct npcm750_vcd *vcd = file->private_data;
+	struct npcm750_vcd *priv = file->private_data;
 
-	if (atomic_dec_return(&vcd->clients) == 0)
-		npcm750_vcd_stop(vcd);
+	if (atomic_dec_return(&priv->clients) == 0)
+		npcm750_vcd_stop(priv);
 
-	dev_dbg(vcd->dev, "close: client %d\n", atomic_read(&vcd->clients));
+	dev_dbg(priv->dev, "close: client %d\n", atomic_read(&priv->clients));
 	return 0;
 }
 
 static long
-npcm750_do_vcd_ioctl(struct npcm750_vcd *vcd, unsigned int cmd,
+npcm750_do_vcd_ioctl(struct npcm750_vcd *priv, unsigned int cmd,
 		     unsigned long arg)
 {
+	struct regmap *vcd = priv->vcd_regmap;
 	void __user *argp = (void __user *)arg;
 	long ret = 0;
 
-	mutex_lock(&vcd->mlock);
+	mutex_lock(&priv->mlock);
 	switch (cmd) {
 	case VCD_IOCGETINFO:
-		ret = copy_to_user(argp, &vcd->info, sizeof(vcd->info))
+		ret = copy_to_user(argp, &priv->info, sizeof(priv->info))
 			? -EFAULT : 0;
 		break;
 	case VCD_IOCSENDCMD:
@@ -1218,47 +1321,47 @@ npcm750_do_vcd_ioctl(struct npcm750_vcd *vcd, unsigned int cmd,
 		ret = copy_from_user(&vcd_cmd, argp, sizeof(vcd_cmd))
 			? -EFAULT : 0;
 		if (!ret) {
-			vcd->status = 0;
-			reinit_completion(&vcd->complete);
+			priv->status = 0;
+			reinit_completion(&priv->complete);
 
-			npcm750_vcd_free_diff_table(vcd);
+			npcm750_vcd_free_diff_table(priv);
 
 			if (vcd_cmd != VCD_CMD_OP_CAPTURE)
-				npcm750_vcd_update(vcd, VCD_MODE, VCD_MODE_IDBC,
+				regmap_update_bits(vcd, VCD_MODE, VCD_MODE_IDBC,
 					VCD_MODE_IDBC);
 
-			npcm750_vcd_update(vcd, VCD_MODE, VCD_MODE_VCDE,
+			regmap_update_bits(vcd, VCD_MODE, VCD_MODE_VCDE,
 				VCD_MODE_VCDE);
 
-			npcm750_vcd_command(vcd, vcd_cmd);
-			timeout = wait_for_completion_interruptible_timeout(&vcd->complete,
+			npcm750_vcd_command(priv, vcd_cmd);
+			timeout = wait_for_completion_interruptible_timeout(&priv->complete,
 			    VCD_OP_TIMEOUT);
-			if (timeout <= 0 || !npcm750_vcd_op_done(vcd)) {
-				dev_dbg(vcd->dev, "VCD_OP_BUSY\n");
+			if (timeout <= 0 || !npcm750_vcd_op_done(priv)) {
+				dev_dbg(priv->dev, "VCD_OP_BUSY\n");
 
-				if (vcd->status == 0)
-					vcd->status = npcm750_vcd_read(vcd, VCD_STAT);
+				if (priv->status == 0)
+					regmap_read(vcd, VCD_STAT, &priv->status);
 
-				npcm750_vcd_io_reset(vcd);
-				ret = copy_to_user(argp, &vcd->status, sizeof(vcd->status))
+				npcm750_vcd_io_reset(priv);
+				ret = copy_to_user(argp, &priv->status, sizeof(priv->status))
 					? -EFAULT : 0;
 			}
 
-			npcm750_vcd_update(vcd, VCD_MODE, VCD_MODE_VCDE,
+			regmap_update_bits(vcd, VCD_MODE, VCD_MODE_VCDE,
 				~VCD_MODE_VCDE);
 
 			if (vcd_cmd != VCD_CMD_OP_CAPTURE && timeout > 0) {
-				npcm750_vcd_update(vcd, VCD_MODE, VCD_MODE_IDBC,
+				regmap_update_bits(vcd, VCD_MODE, VCD_MODE_IDBC,
 					~VCD_MODE_IDBC);
-				npcm750_short_vcd_reset(vcd);
-				npcm750_vcd_get_diff_table(vcd);
+				npcm750_short_vcd_reset(priv);
+				npcm750_vcd_get_diff_table(priv);
 			}
 		}
 		break;
 	}
 	case VCD_IOCCHKRES:
 	{
-		int changed = npcm750_vcd_get_resolution(vcd);
+		int changed = npcm750_vcd_get_resolution(priv);
 
 		if (changed < 0) {
 			ret = -EFAULT;
@@ -1273,13 +1376,13 @@ npcm750_do_vcd_ioctl(struct npcm750_vcd *vcd, unsigned int cmd,
 	{
 		struct rect_list *list;
 		struct rect r;
-		struct list_head *head = &vcd->list;
+		struct list_head *head = &priv->list;
 
-		if (vcd->rect_cnt == 0) {
+		if (priv->rect_cnt == 0) {
 			r.x = 0;
 			r.y = 0;
-			r.w = vcd->info.hdisp;
-			r.h = vcd->info.vdisp;
+			r.w = priv->info.hdisp;
+			r.h = priv->info.vdisp;
 		} else {
 			list = list_first_entry_or_null(head,
 							struct rect_list,
@@ -1298,7 +1401,7 @@ npcm750_do_vcd_ioctl(struct npcm750_vcd *vcd, unsigned int cmd,
 			if (list) {
 				list_del(&list->list);
 				kfree(list);
-				vcd->rect_cnt--;
+				priv->rect_cnt--;
 			}
 		}
 		ret = copy_to_user(argp, &r, sizeof(struct rect))
@@ -1306,7 +1409,7 @@ npcm750_do_vcd_ioctl(struct npcm750_vcd *vcd, unsigned int cmd,
 		break;
 	}
 	case VCD_IOCDIFFCNT:
-		ret = copy_to_user(argp, &vcd->rect_cnt, sizeof(int))
+		ret = copy_to_user(argp, &priv->rect_cnt, sizeof(int))
 			? -EFAULT : 0;
 		break;
 	case VCD_IOCDEMODE:
@@ -1315,69 +1418,69 @@ npcm750_do_vcd_ioctl(struct npcm750_vcd *vcd, unsigned int cmd,
 
 		ret = copy_from_user(&mode, argp, sizeof(mode))
 			? -EFAULT : 0;
-		if (!ret && vcd->de_mode != mode) {
-			vcd->de_mode = mode;
-			npcm750_vcd_stop(vcd);
-			npcm750_vcd_init(vcd);
+		if (!ret && priv->de_mode != mode) {
+			priv->de_mode = mode;
+			npcm750_vcd_stop(priv);
+			npcm750_vcd_init(priv);
 		}
 
 		break;
 	}
 	case VCD_IOCRESET:
-		npcm750_vcd_io_reset(vcd);
+		npcm750_vcd_io_reset(priv);
 
 		break;
 	case VCD_GETREG:
 	{
-		ret = copy_from_user(&vcd->info, argp, sizeof(vcd->info))
+		ret = copy_from_user(&priv->info, argp, sizeof(priv->info))
 			? -EFAULT : 0;
-		if (!ret && vcd->info.reg <= VCD_FIFO) {
-			vcd->info.reg_val = readl(vcd->base + vcd->info.reg);
+		if (!ret && priv->info.reg <= VCD_FIFO) {
+			regmap_read(vcd, priv->info.reg, &priv->info.reg_val);
 		} else if(!ret &&
-			(vcd->info.reg >= GFXI_START) &&
-			(vcd->info.reg <= GFXI_FIFO)) {
-			struct regmap *gfxi = vcd->gfx_regmap;
+			(priv->info.reg >= GFXI_START) &&
+			(priv->info.reg <= GFXI_FIFO)) {
+			struct regmap *gfxi = priv->gfx_regmap;
 			u32 value;
 
-			vcd->info.reg = (vcd->info.reg & GFXI_MASK);
-			regmap_read(gfxi, vcd->info.reg, &value);
-			vcd->info.reg_val = value;
+			priv->info.reg = (priv->info.reg & GFXI_MASK);
+			regmap_read(gfxi, priv->info.reg, &value);
+			priv->info.reg_val = value;
 		}
 
-		ret = copy_to_user(argp, &vcd->info, sizeof(vcd->info))
+		ret = copy_to_user(argp, &priv->info, sizeof(priv->info))
 			? -EFAULT : 0;
 		break;
 	}
 	case VCD_SETREG:
 	{
-		ret = copy_from_user(&vcd->info, argp, sizeof(vcd->info))
+		ret = copy_from_user(&priv->info, argp, sizeof(priv->info))
 			? -EFAULT : 0;
 
-		if (!ret && vcd->info.reg <= VCD_FIFO)
-			writel(vcd->info.reg_val, vcd->base + vcd->info.reg);
+		if (!ret && priv->info.reg <= VCD_FIFO)
+			regmap_write(vcd, priv->info.reg, priv->info.reg_val);
 		break;
 	}
 	case VCD_SHORT_RESET:
 	{
-		npcm750_short_vcd_reset(vcd);
+		npcm750_short_vcd_reset(priv);
 		break;
 	}
 
 	default:
 		break;
 	}
-	mutex_unlock(&vcd->mlock);
+	mutex_unlock(&priv->mlock);
 	return ret;
 }
 
 static long
 npcm750_vcd_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
-	struct npcm750_vcd *vcd = file->private_data;
+	struct npcm750_vcd *priv = file->private_data;
 
-	if (!vcd)
+	if (!priv)
 		return -ENODEV;
-	return npcm750_do_vcd_ioctl(vcd, cmd, arg);
+	return npcm750_do_vcd_ioctl(priv, cmd, arg);
 }
 
 static const struct file_operations npcm750_vcd_fops = {
@@ -1388,7 +1491,7 @@ static const struct file_operations npcm750_vcd_fops = {
 	.unlocked_ioctl = npcm750_vcd_ioctl,
 };
 
-static int npcm750_vcd_device_create(struct npcm750_vcd *vcd)
+static int npcm750_vcd_device_create(struct npcm750_vcd *priv)
 {
 	int ret;
 	dev_t dev;
@@ -1399,11 +1502,11 @@ static int npcm750_vcd_device_create(struct npcm750_vcd *vcd)
 		goto err;
 	}
 
-	vcd->dev_t = dev;
+	priv->dev_t = dev;
 
-	cdev_init(&vcd->dev_cdev, &npcm750_vcd_fops);
-	vcd->dev_cdev.owner = THIS_MODULE;
-	ret = cdev_add(&vcd->dev_cdev, MKDEV(MAJOR(dev),  MINOR(dev)), 1);
+	cdev_init(&priv->dev_cdev, &npcm750_vcd_fops);
+	priv->dev_cdev.owner = THIS_MODULE;
+	ret = cdev_add(&priv->dev_cdev, MKDEV(MAJOR(dev),  MINOR(dev)), 1);
 	if (ret < 0) {
 		pr_err("Couldn't cdev_add for vcd, error=%d\n", ret);
 		goto err;
@@ -1417,15 +1520,15 @@ static int npcm750_vcd_device_create(struct npcm750_vcd *vcd)
 		goto err;
 	}
 
-	vcd->dev = device_create(vcd_class, vcd->dev_p,
+	priv->dev = device_create(vcd_class, priv->dev_p,
 				 MKDEV(MAJOR(dev), MINOR(dev)),
-				 vcd,
+				 priv,
 				 DEVICE_NAME);
-	if (IS_ERR(vcd->dev)) {
-		ret = PTR_ERR(vcd->dev);
+	if (IS_ERR(priv->dev)) {
+		ret = PTR_ERR(priv->dev);
 		pr_err("Unable to create device for vcd; errno = %ld\n",
-		       PTR_ERR(vcd->dev));
-		vcd->dev = NULL;
+		       PTR_ERR(priv->dev));
+		priv->dev = NULL;
 		goto err;
 	}
 
@@ -1435,38 +1538,61 @@ static int npcm750_vcd_device_create(struct npcm750_vcd *vcd)
 	return ret;
 }
 
+static const struct regmap_config npcm750_vcd_regmap_cfg = {
+	.reg_bits       = 32,
+	.reg_stride     = 4,
+	.val_bits       = 32,
+	.max_register   = VCD_FIFO,
+};
+
 static int npcm750_vcd_probe(struct platform_device *pdev)
 {
-	struct npcm750_vcd *vcd;
+	struct npcm750_vcd *priv;
+	void __iomem *regs;
 	int ret;
 
-	vcd = kzalloc(sizeof(*vcd), GFP_KERNEL);
-	if (!vcd)
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
 		return -ENOMEM;
 
-	spin_lock_init(&vcd->lock);
-	mutex_init(&vcd->mlock);
+	spin_lock_init(&priv->lock);
+	mutex_init(&priv->mlock);
 
-	vcd->gcr_regmap =
+	priv->gcr_regmap =
 		syscon_regmap_lookup_by_compatible("nuvoton,npcm750-gcr");
-	if (IS_ERR(vcd->gcr_regmap)) {
+	if (IS_ERR(priv->gcr_regmap)) {
 		dev_err(&pdev->dev, "%s: failed to find nuvoton,npcm750-gcr\n",
 			__func__);
-		ret = IS_ERR(vcd->gcr_regmap);
+		ret = IS_ERR(priv->gcr_regmap);
 		goto err;
 	}
 
-	vcd->gfx_regmap =
+	priv->gfx_regmap =
 		syscon_regmap_lookup_by_compatible("nuvoton,npcm750-gfxi");
-	if (IS_ERR(vcd->gfx_regmap)) {
+	if (IS_ERR(priv->gfx_regmap)) {
 		dev_err(&pdev->dev, "%s: failed to find nuvoton,npcm750-gfxi\n",
 			__func__);
-		ret = IS_ERR(vcd->gfx_regmap);
+		ret = IS_ERR(priv->gfx_regmap);
+		goto err;
+	}
+
+	regs = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(regs)) {
+		dev_err(&pdev->dev, "Failed to get regmap!\n");
+		ret = PTR_ERR(regs);
+		goto err;
+	}
+
+	priv->vcd_regmap = devm_regmap_init_mmio(&pdev->dev, regs,
+						&npcm750_vcd_regmap_cfg);
+	if (IS_ERR(priv->vcd_regmap)) {
+		dev_err(&pdev->dev, "Failed to init regmap!\n");
+		ret = PTR_ERR(priv->vcd_regmap);
 		goto err;
 	}
 
 	ret = of_property_read_u32_index(pdev->dev.of_node,
-			     "phy-memory", 0, &vcd->frame_start);
+			     "phy-memory", 0, &priv->frame_start);
 	if (ret) {
 		dev_err(&pdev->dev, "%s: failed to find memory address\n",
 			__func__);
@@ -1474,74 +1600,66 @@ static int npcm750_vcd_probe(struct platform_device *pdev)
 	}
 
 	ret = of_property_read_u32_index(pdev->dev.of_node,
-			     "phy-memory", 1, &vcd->frame_len);
+			     "phy-memory", 1, &priv->frame_len);
 	if (ret) {
 		dev_err(&pdev->dev, "%s: failed to find memory length\n",
 			__func__);
 		goto err;
 	}
 
-	vcd->base = of_iomap(pdev->dev.of_node, 0);
-	if (IS_ERR(vcd->base)) {
-		dev_err(&pdev->dev, "%s: failed to ioremap vcd base address\n",
-			__func__);
-		ret = PTR_ERR(vcd->base);
-		goto err;
-	}
-
 	ret = of_property_read_u32(pdev->dev.of_node,
-			     "de-mode", &vcd->de_mode);
+			     "de-mode", &priv->de_mode);
 	if (ret)
-		vcd->de_mode = 1;
+		priv->de_mode = 1;
 
-	vcd->dev_p = &pdev->dev;
+	priv->dev_p = &pdev->dev;
 
-	ret = npcm750_vcd_device_create(vcd);
+	ret = npcm750_vcd_device_create(priv);
 	if (ret)
 		goto err;
 
-	vcd->irq = of_irq_get(pdev->dev.of_node, 0);
-	ret = request_irq(vcd->irq, npcm750_vcd_irq_handler,
-			  IRQF_SHARED, vcd_name, vcd->dev);
+	priv->irq = of_irq_get(pdev->dev.of_node, 0);
+	ret = request_irq(priv->irq, npcm750_vcd_irq_handler,
+			  IRQF_SHARED, vcd_name, priv->dev);
 	if (ret) {
 		dev_err(&pdev->dev, "%s: failed to request irq for vcd\n",
 			__func__);
 		goto irq_err;
 	}
 
-	platform_set_drvdata(pdev, vcd);
-	INIT_LIST_HEAD(&vcd->list);
-	init_completion(&vcd->complete);
+	platform_set_drvdata(pdev, priv);
+	INIT_LIST_HEAD(&priv->list);
+	init_completion(&priv->complete);
 
 	pr_info("NPCM750 VCD Driver probed %s\n", VCD_VERSION);
 	return 0;
 
 irq_err:
-	device_destroy(vcd_class, vcd->dev_t);
+	device_destroy(vcd_class, priv->dev_t);
 err:
-	kfree(vcd);
+	kfree(priv);
 	return ret;
 }
 
 static int npcm750_vcd_remove(struct platform_device *pdev)
 {
-	struct npcm750_vcd *vcd = platform_get_drvdata(pdev);
+	struct npcm750_vcd *priv = platform_get_drvdata(pdev);
 
-	npcm750_vcd_stop(vcd);
+	npcm750_vcd_stop(priv);
 
-	free_irq(vcd->irq, vcd->dev);
+	free_irq(priv->irq, priv->dev);
 
-	device_destroy(vcd_class, vcd->dev_t);
+	device_destroy(vcd_class, priv->dev_t);
 
 	class_destroy(vcd_class);
 
-	cdev_del(&vcd->dev_cdev);
+	cdev_del(&priv->dev_cdev);
 
-	unregister_chrdev_region(vcd->dev_t, 1);
+	unregister_chrdev_region(priv->dev_t, 1);
 
-	mutex_destroy(&vcd->mlock);
+	mutex_destroy(&priv->mlock);
 
-	kfree(vcd);
+	kfree(priv);
 
 	return 0;
 }
-- 
2.17.1

