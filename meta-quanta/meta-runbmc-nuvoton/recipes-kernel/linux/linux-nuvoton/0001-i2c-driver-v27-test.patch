From 0ba9c0fe65aa5070dfe76897faeedc3b4a335c5c Mon Sep 17 00:00:00 2001
From: kwliu <kwliu@nuvoton.com>
Date: Mon, 29 Jul 2019 14:17:39 +0800
Subject: [PATCH] i2c-driver v27 test

---
 drivers/i2c/busses/i2c-npcm7xx.c | 930 +++++++++++++++++++++++--------
 1 file changed, 683 insertions(+), 247 deletions(-)

diff --git a/drivers/i2c/busses/i2c-npcm7xx.c b/drivers/i2c/busses/i2c-npcm7xx.c
index 53aba723b061..2886d729070b 100644
--- a/drivers/i2c/busses/i2c-npcm7xx.c
+++ b/drivers/i2c/busses/i2c-npcm7xx.c
@@ -20,7 +20,8 @@
 #include <linux/regmap.h>
 #include <linux/jiffies.h>
 
-#define I2C_VERSION "0.0.16"
+
+#define I2C_VERSION "0.0.26"
 
 //#define _I2C_DEBUG_
 
@@ -389,12 +390,13 @@ struct npcm_i2c {
 
 	u8 			slv_rd_buf[SMBUS_FIFO_SIZE];
 	u8 			slv_wr_buf[SMBUS_FIFO_SIZE];
+  //@@
+  bool    handle_slave;
 #endif
 
 };
 
 
-
 static inline void npcm_smb_select_bank(struct npcm_i2c *bus,
 					enum smb_bank bank)
 {
@@ -410,6 +412,11 @@ static inline void npcm_smb_select_bank(struct npcm_i2c *bus,
 // DEBUG PRINTS:
 //------------------
 static inline bool npcm_smb_is_quick(struct npcm_i2c *bus);
+
+static struct npcm_i2c *buss[16];
+
+
+
 static void pdebug(struct npcm_i2c *bus, char str[20])
 {
 	char str2[65];
@@ -546,6 +553,23 @@ static void pdebug(struct npcm_i2c *bus, char str[20])
 	//	ioread8(bus->reg + NPCM_SMBCTL5 ),
 	//	ioread8(bus->reg + NPCM_SMBFIF_CTL ));
 	//npcm_smb_select_bank(bus, SMB_BANK_1);
+
+	if (str[0] != '#') {
+		if (bus->num == 0 )
+			pdebug(buss[1], "#1_");
+		if (bus->num == 1 )
+			pdebug(buss[0], "#0_");
+		if (bus->num == 6 )
+			pdebug(buss[7], "#7_");
+		if (bus->num == 7 )
+			pdebug(buss[6], "#6_");
+		if (bus->num == 8 )
+			pdebug(buss[9], "#9_");
+		if (bus->num == 9 )
+			pdebug(buss[8], "#8_");
+	}
+
+
 	return;
 
 
@@ -582,7 +606,7 @@ static void npcm_smb_init_params(struct npcm_i2c *bus)
 	bus->event_log = 0;
 	bus->read_block_use = false;
 	bus->int_time_stamp = 0;
-	bus->cmd_err = -EPERM;
+	bus->cmd_err = -EBUSY;
 	bus->PEC_use = false;
 	bus->PEC_mask = 0;
 	if(bus->slave)
@@ -702,6 +726,24 @@ static void npcm_smb_enable(struct npcm_i2c *bus)
 		 bus->reg + NPCM_SMBCTL2);
 }
 
+static bool npcm_smb_wait_for_bus_free(struct npcm_i2c *bus)
+{
+	unsigned long timeout1 = jiffies + bus->adap.timeout;
+	while ((ioread8(bus->reg + NPCM_SMBCST) & NPCM_SMBCST_BB) == 1){
+      printk("b:%d bb\r\n", bus->num);
+		if (time_after(jiffies, timeout1)) {
+			pdebug(bus, "ETIMEDOUT");
+			bus->cmd_err = -ETIMEDOUT;
+      
+      printk("b:%d bb timeout\r\n", bus->num);
+			return false;
+		}
+		cpu_relax();
+	}
+	return true;
+
+}
+
 // enable\disable end of busy (EOB) interrupt
 static inline void npcm_smb_eob_int(struct npcm_i2c *bus, bool enable)
 {
@@ -873,6 +915,12 @@ static void npcm_smb_reset(struct npcm_i2c *bus)
 
 	// Reset driver status
 	bus->state = SMB_IDLE;
+
+  //@@
+  if(bus->handle_slave)
+  {
+      bus->handle_slave = false;
+  }
 }
 
 static inline bool npcm_smb_is_master(struct npcm_i2c *bus)
@@ -890,75 +938,84 @@ static void npcm_smb_callback(struct npcm_i2c *bus,
 
 	NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_CB);
 
-	switch (op_status) {
-	case SMB_MASTER_DONE_IND:
-	// Master transaction finished and all transmit bytes were sent
-	// info: number of bytes actually received after the Master
-	//	receive operation (if Master didn't issue receive it
-	//	should be 0)
-	// Notify that not all data was received on Master or Slave
-	// info:
-	//	on receive: number of actual bytes received
-	//	when PEC is used even if 'info' is the expected number
-	//	of bytes, it means that PEC error occurred.
-	{
-		if (msgs[0].flags & I2C_M_RD)
-			msgs[0].len = info;
-		else if (msgs_num == 2 && msgs[1].flags & I2C_M_RD)
-			msgs[1].len = info;
-
-		bus->cmd_err = 0;
-		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_DONE);
-
-		if((ioread8(bus->reg + NPCM_SMBCST) & NPCM_SMBCST_BB) != 0)
-			pdebug_lvl2(bus, "WARNING busy done");
-		complete(&bus->cmd_complete);
-		if(bus->slave)
-		    bus->master_or_slave = SMB_SLAVE;
-	}
-	break;
+	if (completion_done(&bus->cmd_complete) == true) {
+		pdebug(bus, "CB com err");
+	}
+
+
+		switch (op_status) {
+		case SMB_MASTER_DONE_IND:
+		// Master transaction finished and all transmit bytes were sent
+		// info: number of bytes actually received after the Master
+		//	receive operation (if Master didn't issue receive it
+		//	should be 0)
+		// Notify that not all data was received on Master or Slave
+		// info:
+		//	on receive: number of actual bytes received
+		//	when PEC is used even if 'info' is the expected number
+		//	of bytes, it means that PEC error occurred.
+		{
+			if(bus->msgs != NULL) {
+				if (msgs[0].flags & I2C_M_RD)
+					msgs[0].len = info;
+				else if (msgs_num == 2 && msgs[1].flags & I2C_M_RD)
+					msgs[1].len = info;
+			}
+			bus->cmd_err = 0;
+			NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_DONE);
 
-	case SMB_NACK_IND:
-		// MASTER transmit got a NAK before transmitting all bytes
-		// info: number of transmitted bytes
-		bus->cmd_err = -EAGAIN;
-		pdebug_lvl2(bus, "CB-NACK ");
-		if (bus->master_or_slave == SMB_MASTER) {
-			complete(&bus->cmd_complete);
-			if(bus->slave)
-			    bus->master_or_slave = SMB_SLAVE;
+			if((ioread8(bus->reg + NPCM_SMBCST) & NPCM_SMBCST_BB) != 0)
+				pdebug_lvl2(bus, "WARNING busy done");
+			if (completion_done(&bus->cmd_complete) == false)
+				complete(&bus->cmd_complete);
 		}
+		break;
 
+		case SMB_NACK_IND:
+			// MASTER transmit got a NAK before transmitting all bytes
+			// info: number of transmitted bytes
+			bus->cmd_err = -ENXIO;
+			pdebug_lvl2(bus, "CB-NACK ");
+			if (bus->master_or_slave == SMB_MASTER) {
+				complete(&bus->cmd_complete);
+			}
 
-		break;
-	case SMB_BUS_ERR_IND:
-		// Bus error
-		// info: has no meaning
-		bus->cmd_err = -EIO;
-		pdebug_lvl2(bus, "CB BER  ");
-		if (bus->master_or_slave == SMB_MASTER) {
-			complete(&bus->cmd_complete);
-			if(bus->slave)
-			    bus->master_or_slave = SMB_SLAVE;
 
+			break;
+		case SMB_BUS_ERR_IND:
+			// Bus error
+			// info: has no meaning
+			bus->cmd_err = -EIO;
+			pdebug_lvl2(bus, "CB BER  ");
+			if (bus->master_or_slave == SMB_MASTER) {
+				complete(&bus->cmd_complete);
+			}
+
+			break;
+		case SMB_WAKE_UP_IND:
+			pdebug_lvl2(bus, "wake_up");
+			// SMBus wake up
+			// info: has no meaning
+			break;
+		default:
+			pdebug_lvl2(bus, "CB default");
+			break;
 		}
 
-		break;
-	case SMB_WAKE_UP_IND:
-		pdebug_lvl2(bus, "wake_up");
-		// SMBus wake up
-		// info: has no meaning
-		break;
-	default:
-		pdebug_lvl2(bus, "CB default");
-		break;
-	}
+
 	bus->operation = SMB_NO_OPER;
+	if(bus->slave)
+		bus->master_or_slave = SMB_SLAVE;
 }
 
 
 static u32 npcm_smb_get_fifo_fullness(struct npcm_i2c *bus)
 {
+  //@@
+  //if((3 == bus->num) || (5 == bus->num))
+  //{
+	//    printk("!!!b:%d oper:%s s:%d\r\n", bus->num, (SMB_WRITE_OPER == bus->operation)?"write":"read", (SMB_WRITE_OPER == bus->operation)?FIELD_GET(NPCM_SMBTXF_STS_TX_BYTES,ioread8(bus->reg + NPCM_SMBTXF_STS)) : FIELD_GET(NPCM_SMBRXF_STS_RX_BYTES,ioread8(bus->reg + NPCM_SMBRXF_STS)) );
+  //}
 	if (bus->operation == SMB_WRITE_OPER)
 		return FIELD_GET(NPCM_SMBTXF_STS_TX_BYTES,
 				 ioread8(bus->reg + NPCM_SMBTXF_STS));
@@ -975,6 +1032,8 @@ static void npcm_smb_write_to_fifo_master(struct npcm_i2c *bus,
 	pdebug_lvl2(bus, "wr_fifo_master");
 	// Fill the FIFO, while the FIFO is not full and there are more bytes to
 	// write
+	if (max_bytes_to_send == 0)
+		return;
 	while ((max_bytes_to_send--) && (SMBUS_FIFO_SIZE -
 					 npcm_smb_get_fifo_fullness(bus))) {
 		// write the data
@@ -985,6 +1044,7 @@ static void npcm_smb_write_to_fifo_master(struct npcm_i2c *bus,
 				npcm_smb_write_PEC(bus);
 				bus->wr_ind++;
 			} else {
+        
 				npcm_smb_wr_byte(bus,
 						 bus->wr_buf[bus->wr_ind++]);
 			}
@@ -1003,6 +1063,16 @@ static void npcm_smb_write_to_fifo_slave(struct npcm_i2c *bus, u16 max_bytes_to_
 	npcm_smb_clear_fifo_int(bus);
 	npcm_smb_clear_tx_fifo(bus);
 	iowrite8(0, bus->reg + NPCM_SMBTXF_CTL);
+  //@@
+  //if((3 == bus->num) || (5 == bus->num))
+  //{
+  //if(5 == bus->num)
+  //{
+	//    printk("!!!%s space:%d [ind:%d size:%d]\r\n", __func__, (SMBUS_FIFO_SIZE - npcm_smb_get_fifo_fullness(bus)), bus->slv_wr_ind, bus->slv_wr_size);
+  //}
+  //}
+	if (max_bytes_to_send == 0)
+		return;
 
 	while ((max_bytes_to_send--) && (SMBUS_FIFO_SIZE -
 					 npcm_smb_get_fifo_fullness(bus))) {
@@ -1010,6 +1080,11 @@ static void npcm_smb_write_to_fifo_slave(struct npcm_i2c *bus, u16 max_bytes_to_
 		if (bus->slv_wr_size > 0) {
 			npcm_smb_wr_byte(bus,
 					 bus->slv_wr_buf[bus->slv_wr_ind % SMBUS_FIFO_SIZE]);
+     //if(5 == bus->num)
+     //if((3 == bus->num) || (5 == bus->num))
+     //{
+     //    printk("write: 0x%x\r\n", bus->slv_wr_buf[bus->slv_wr_ind % SMBUS_FIFO_SIZE]);
+     //}
 			bus->slv_wr_ind = (bus->slv_wr_ind + 1) % SMBUS_FIFO_SIZE;
 			bus->slv_wr_size--;  // more bytes in fifo, less in cyclic buffer.
 		}
@@ -1017,6 +1092,10 @@ static void npcm_smb_write_to_fifo_slave(struct npcm_i2c *bus, u16 max_bytes_to_
 			break;
 	}
 
+  //if(5 == bus->num)
+  //{
+	//    printk("!!!%s [ind:%d size:%d]\r\n", __func__, bus->slv_wr_ind, bus->slv_wr_size);
+  //}
 	pdebug_lvl2(bus, "wr_fifo_done");
 }
 #endif
@@ -1072,6 +1151,66 @@ static void npcm_smb_set_fifo(struct npcm_i2c *bus, int nread, int nwrite)
 
 }
 
+static void npcm_smb_master_read_from_fifo(struct npcm_i2c *bus, u8 bytes_in_fifo)
+{
+	u8 data;
+	while (bytes_in_fifo--) {
+		npcm_smb_rd_byte(bus, &data);
+    //@@
+    //if((3 == bus->num) || (5 == bus->num))
+    //{
+	  //    printk("!!!b:%d mrff data:0x%x smp_processor_id:0x%x\r\n", bus->num, data, smp_processor_id());
+    //}
+		
+        //@@
+        //if(3 == bus->num)
+        //{
+        //    printk("b:%d v:0x%x\r\n", bus->num, data);
+        //}
+			if (bus->rd_ind < bus->rd_size) {
+				bus->rd_buf[bus->rd_ind++] = data;
+				if (bus->rd_ind == 1 && bus->read_block_use){
+
+					// First byte indicates length in block protocol
+					bus->rd_size = data;
+					pdebug_lvl2(bus, "blk rcv");
+				}
+			}
+		}
+}
+
+static void npcm_smb_slave_read_from_fifo(struct npcm_i2c *bus, u8 bytes_in_fifo)
+{
+	u8 data;
+	while (bytes_in_fifo--) {
+		npcm_smb_rd_byte(bus, &data);
+    //@@
+   //if((3 == bus->num) || (5 == bus->num))
+   //{
+	 //    printk("!!!b:%d srff data:0x%x smp_processor_id:0x%x\r\n", bus->num, data, smp_processor_id());
+   //}
+
+		// SMB_SLAVE:
+//printk("s fifo read\r\n");
+#if IS_ENABLED(CONFIG_I2C_SLAVE)
+   //@@
+   //if(5 == bus->num)
+   //if((3==bus->num) || (5 == bus->num))
+   //{
+   //    printk("b:%d slv_rd_ind:%d data:0x%x\r\n", bus->num, bus->slv_rd_ind, data);
+   //}
+	 bus->slv_rd_buf[bus->slv_rd_ind % SMBUS_FIFO_SIZE] = data;
+	 bus->slv_rd_ind++;
+   
+	 // First byte indicates length in block protocol
+	 if (bus->slv_rd_ind == 1 && bus->read_block_use)
+	 	bus->rd_size = data;
+
+#endif
+		
+	}
+}
+
 static void npcm_smb_read_from_fifo(struct npcm_i2c *bus, u8 bytes_in_fifo)
 {
 	u8 data;
@@ -1081,8 +1220,16 @@ static void npcm_smb_read_from_fifo(struct npcm_i2c *bus, u8 bytes_in_fifo)
 #endif
 	while (bytes_in_fifo--) {
 		npcm_smb_rd_byte(bus, &data);
-
-		if (bus->master_or_slave == SMB_MASTER) {
+    //if((3 == bus->num) || (5 == bus->num))
+    //{
+	      //printk("!!!b:%d rff data:0x%x smp_processor_id:0x%x\r\n", bus->num, data, smp_processor_id());
+    //}
+		if (npcm_smb_is_master(bus)) {
+        //@@
+        //if(3 == bus->num)
+        //{
+        //    printk("b:%d v:0x%x\r\n", bus->num, data);
+        //}
 			if (bus->rd_ind < bus->rd_size) {
 				bus->rd_buf[bus->rd_ind++] = data;
 				if (bus->rd_ind == 1 && bus->read_block_use){
@@ -1093,9 +1240,17 @@ static void npcm_smb_read_from_fifo(struct npcm_i2c *bus, u8 bytes_in_fifo)
 				}
 			}
 		} else { // SMB_SLAVE:
+//printk("s fifo read\r\n");
 #if IS_ENABLED(CONFIG_I2C_SLAVE)
+        //@@
+        //if(5 == bus->num)
+        //if((3==bus->num) || (5 == bus->num))
+        //{
+        //    printk("b:%d slv_rd_ind:%d data:0x%x\r\n", bus->num, bus->slv_rd_ind, data);
+        //}
 				bus->slv_rd_buf[bus->slv_rd_ind % SMBUS_FIFO_SIZE] = data;
 				bus->slv_rd_ind++;
+        
 				if (bus->slv_rd_ind == 1 && bus->read_block_use)
 					// First byte indicates length in block protocol
 					bus->rd_size = data;
@@ -1109,49 +1264,49 @@ static void npcm_smb_read_from_fifo(struct npcm_i2c *bus, u8 bytes_in_fifo)
 static int npcm_smb_master_abort(struct npcm_i2c *bus)
 {
 	int ret = 0;
-	u8 data;
 	int len;
 
 	NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_ABORT);
 
-	//pdebug(bus, " abort data 1 ");
+	pdebug_lvl2(bus, " abort data 1 ");
 
 	// Only current master is allowed to issue Stop Condition
 	if (npcm_smb_is_master(bus)) {
-		//pdebug(bus, " abort data 2 ");
+		pdebug_lvl2(bus, " abort data 2 ");
 		// stoping in the middle, not waing for interrupts anymore
 		npcm_smb_eob_int(bus,  false);
 
 		// Generate a STOP condition (after next wr\rd from fifo:
 		npcm_smb_master_stop(bus);
 
-		if (bus->operation == SMB_WRITE_OPER){
-			npcm_smb_set_fifo(bus, 0, 1);
-			// dummy write to FIFO:
-			npcm_smb_wr_byte(bus, 0xFF);
-			pdebug_lvl2(bus, " abort data wr");
-		}
-		else {
+		if ((NPCM_SMBST_XMIT & ioread8(bus->reg + NPCM_SMBST)) == 0 ){
 			// gracefully abort read transaction
 			len = npcm_smb_get_fifo_fullness(bus);
 
-			if (len > 0)
-				npcm_smb_read_from_fifo(bus, len);
-			npcm_smb_set_fifo(bus, 1, 0);
-			npcm_smb_rd_byte(bus, &data);
-			pdebug_lvl2(bus, " abort data rd");
+			//@@
+			//if (len > 0)
+			//	npcm_smb_read_from_fifo(bus, len);
+		    if (len > 0)
+			{
+				npcm_smb_master_read_from_fifo(bus, len);
+			}
 		}
 
-		udelay(100); // TODO, replace with TO polling on BB bit.
+		npcm_smb_wait_for_bus_free(bus);
 
 		// Clear NEGACK, STASTR and BER bits
-		iowrite8(0xFF, bus->reg + NPCM_SMBST);
+		iowrite8(NPCM_SMBST_BER | NPCM_SMBST_NEGACK | NPCM_SMBST_STASTR, bus->reg + NPCM_SMBST);
 
 		pdebug_lvl2(bus, " abort data 3 ");
 
-		npcm_smb_reset(bus);
 	}
 
+  //@@
+  if(bus->handle_slave)
+  {
+      bus->handle_slave = false;
+  }
+
 	return ret;
 }
 
@@ -1327,6 +1482,12 @@ static int npcm_i2c_slave_get_wr_buf(struct npcm_i2c *bus)
 		if (bus->slv_wr_size >= SMBUS_FIFO_SIZE)
 			break;
 		i2c_slave_event(bus->slave, I2C_SLAVE_READ_REQUESTED, &value);
+    //@@
+    //if(5 == bus->num)
+    //if((3==bus->num) || (5 == bus->num))
+    //{
+		//    printk("b:%d i:%d->   recv 0x%x\n", bus->num, i, value);
+    //}
 		bus->slv_wr_buf[(bus->slv_wr_ind + bus->slv_wr_size) % SMBUS_FIFO_SIZE] = value;
 		bus->slv_wr_size++;
 		i2c_slave_event(bus->slave, I2C_SLAVE_READ_PROCESSED, &value);
@@ -1352,8 +1513,15 @@ static void npcm_i2c_slave_send_rd_buf(struct npcm_i2c *bus)
 	int i;
 
 	for (i = 0; i < bus->slv_rd_ind; i++){
-#ifdef _I2C_DEBUG_
-		printk("->   send 0x%x\n", bus->slv_rd_buf[i]);
+      //@@
+//#ifdef _I2C_DEBUG_
+#if 1
+    //@@
+    //if(5 == bus->num)
+    //if((3==bus->num) || (5 == bus->num))
+    //{
+		//    printk("b:%d i:%d->   send 0x%x\n", bus->num, i, bus->slv_rd_buf[i]);
+    //}
 #endif
 		i2c_slave_event(bus->slave, I2C_SLAVE_WRITE_RECEIVED, &bus->slv_rd_buf[i]);
 	}
@@ -1369,6 +1537,7 @@ static void npcm_i2c_slave_send_rd_buf(struct npcm_i2c *bus)
 	bus->slv_rd_ind = 0;
 	bus->slv_rd_size = 32*1024;
 
+	npcm_smb_clear_fifo_int(bus);
 	npcm_smb_clear_rx_fifo(bus);
 
 
@@ -1410,8 +1579,6 @@ static bool npcm_smb_slave_start_xmit(struct npcm_i2c *bus, u16 nwrite,
 	// get the next buffer
 	npcm_i2c_slave_get_wr_buf(bus);
 
-	npcm_smb_clear_fifo_int(bus);
-
 	if (nwrite > 0) {
 		// Fill the FIFO with data
 		npcm_smb_write_to_fifo_slave(bus, nwrite);
@@ -1422,12 +1589,12 @@ static bool npcm_smb_slave_start_xmit(struct npcm_i2c *bus, u16 nwrite,
 }
 
 
-
+#if 0
 static void npcm_smb_slave_abort(struct npcm_i2c *bus)
 {
 	volatile u8 temp;
 
-	pdebug(bus, "slv abort");
+	pdebug_lvl2(bus, "slv abort");
 	// Disable int.
 	npcm_smb_int_enable(bus, false);
 
@@ -1457,6 +1624,7 @@ static void npcm_smb_slave_abort(struct npcm_i2c *bus)
 	// Reset driver status
 	bus->state = SMB_IDLE;
 }
+#endif
 
 
 // currently slave IF only supports single byte operations.
@@ -1478,21 +1646,48 @@ static int npcm_i2c_slave_wr_buf_sync(struct npcm_i2c *bus)
 
 
 	if(left_in_fifo >= SMBUS_FIFO_SIZE)
+  {
+    //if(5 == bus->num)
+    //{
+    //    printk("!!!1\r\n");
+    //}
 		return left_in_fifo;
+  }
 
 	if (bus->slv_wr_size >= SMBUS_FIFO_SIZE) {
 #ifdef _I2C_DEBUG_
 		printk("wr buf full, [%d - %d] left %d",bus->slv_wr_ind, bus->slv_wr_size , left_in_fifo);
 #endif
+    //if(5 == bus->num)
+    //{
+    //    printk("!!!2\r\n");
+		//    printk("wr buf full, [ind:%d size:%d] left %d\r\n",bus->slv_wr_ind, bus->slv_wr_size , left_in_fifo);
+    //}
 		return left_in_fifo; // you can't fill a cup which is already full
 	}
 
+  //if(5 == bus->num)
+  //{
+	//	    printk("!!!wr buf , [ind:%d size:%d] left %d\r\n",bus->slv_wr_ind, bus->slv_wr_size , left_in_fifo);
+  //}
+
 	// update the wr fifo ind, back to the untransmitted bytes:
 	bus->slv_wr_ind = bus->slv_wr_ind - left_in_fifo;
 	bus->slv_wr_size = bus->slv_wr_size + left_in_fifo;
+  //if(5 == bus->num)
+  //{
+	//	    printk("updated wr buf , [ind:%d size:%d] left %d\r\n",bus->slv_wr_ind, bus->slv_wr_size , left_in_fifo);
+  //}
 
 	if (bus->slv_wr_ind < 0)
+  {
 		bus->slv_wr_ind += SMBUS_FIFO_SIZE;
+    //if(5 == bus->num)
+    //{
+    //    printk("!!!3\r\n");
+	  // printk("wr buf full, [ind:%d size:%d] left %d\r\n",bus->slv_wr_ind, bus->slv_wr_size , left_in_fifo);
+    //}
+  }
 
 
 	return left_in_fifo;
@@ -1503,28 +1698,32 @@ static irqreturn_t npcm_smb_int_slave_handler(struct npcm_i2c *bus)
 {
 	irqreturn_t ret = IRQ_NONE;
 
-	// spin_lock(&bus->lock);
 	// Slave: A negative acknowledge has occurred
 	if (FIELD_GET(NPCM_SMBST_NEGACK , ioread8(bus->reg + NPCM_SMBST))) {
-
+    //if(5 == bus->num)
+    //{
+	  //  printk("!!!s nack\r\n");
+    //}
+    //if( (3 == bus->num) || (5 == bus->num) )
+    //{
+    // printk("b:%d s nack smp_processor_id:0x%x\r\n", bus->num, smp_processor_id());
+    //}
 		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_NACK);
 		bus->stop_ind = SMB_NACK_IND;
-
+//printk("s nack\r\n");
 		npcm_i2c_slave_wr_buf_sync(bus);
 		if (bus->fifo_use) {
 			// clear the FIFO
 			iowrite8(NPCM_SMBFIF_CTS_CLR_FIFO,
 				 bus->reg + NPCM_SMBFIF_CTS);
 		}
-		//npcm_smb_clear_rx_fifo(bus);
-		//npcm_smb_clear_tx_fifo(bus);
-
 
 		pdebug_lvl2(bus, "int NACK slave");
 
 		// In slave write operation, NACK is OK, otherwise it is a problem
 		bus->stop_ind = SMB_NO_STATUS_IND;
 		bus->operation = SMB_NO_OPER;
+		bus->own_slave_addr = 0xFF;
 
 		// Slave has to wait for SMB_STOP to decide this is the end of the transaction.
 		// Therefore transaction is not yet considered as done
@@ -1544,8 +1743,24 @@ static irqreturn_t npcm_smb_int_slave_handler(struct npcm_i2c *bus)
 		iowrite8(NPCM_SMBFIF_CTS_CLR_FIFO,
 				 bus->reg + NPCM_SMBFIF_CTS);
 		npcm_smb_init_params(bus);
+//printk("s ber\r\n");
 		bus->state = SMB_IDLE;
+    //if( (3 == bus->num) || (5 == bus->num) )
+    //{
+    // printk("b:%d s ber smp_processor_id:0x%x\r\n", bus->num, smp_processor_id());
+    //}
+		// in BER case, we are not sure if SMBST.MASTER is accurate:
+		if (completion_done(&bus->cmd_complete) == false) {
+			bus->cmd_err = -EIO;
+			complete(&bus->cmd_complete);
+		}
+		bus->own_slave_addr = 0xFF;
 		iowrite8(NPCM_SMBST_BER, bus->reg + NPCM_SMBST);
+    //@@
+    if(bus->handle_slave)
+    {
+        bus->handle_slave = false;
+    }
 		ret =  IRQ_HANDLED;
 	}
 
@@ -1554,11 +1769,24 @@ static irqreturn_t npcm_smb_int_slave_handler(struct npcm_i2c *bus)
 	if (FIELD_GET(NPCM_SMBST_SLVSTP , ioread8(bus->reg + NPCM_SMBST))) {
 
 		pdebug_lvl2(bus, "int slv stop");
-
+//printk("s stop\r\n");
 		bus->stop_ind = SMB_SLAVE_DONE_IND;
 
+    //if((3 == bus->num) || (5 == bus->num))
+    //{
+	  //  printk("!!!b:%d s stop\r\n", bus->num);
+    //}
+  
 		if (bus->operation == SMB_READ_OPER) {
-			npcm_smb_read_from_fifo(bus, npcm_smb_get_fifo_fullness(bus));
+      //@@
+      //if(5 == bus->num)
+      //if((3 == bus->num) || (5 == bus->num))
+      //{
+	    //  printk("!!!b:%d s stop read fifo\r\n", bus->num);
+      //}
+      //@@
+			//npcm_smb_read_from_fifo(bus, npcm_smb_get_fifo_fullness(bus));
+      npcm_smb_slave_read_from_fifo(bus, npcm_smb_get_fifo_fullness(bus));
 
 			// if PEC is used and PEC is correct
 			if ((bus->PEC_use == true) &&
@@ -1566,7 +1794,7 @@ static irqreturn_t npcm_smb_int_slave_handler(struct npcm_i2c *bus)
 				bus->stop_ind = SMB_SLAVE_PEC_ERR_IND;
 			}
 		}
-
+    
 		// Slave done transmitting or receiving
 		npcm_i2c_slave_send_rd_buf(bus); // if the buffer is empty nothing will be sent
 
@@ -1578,6 +1806,7 @@ static irqreturn_t npcm_smb_int_slave_handler(struct npcm_i2c *bus)
 		bus->int_cnt = 0;
 		bus->event_log_prev = bus->event_log;
 		bus->event_log = 0;
+		bus->own_slave_addr = 0xFF;
 		pdebug_lvl2(bus, "SLV_DONE");
 
 		i2c_slave_event(bus->slave, I2C_SLAVE_STOP, 0);
@@ -1590,14 +1819,27 @@ static irqreturn_t npcm_smb_int_slave_handler(struct npcm_i2c *bus)
 			npcm_smb_clear_tx_fifo(bus);
 
 			// clear the FIFO
-			iowrite8(NPCM_SMBFIF_CTS_CLR_FIFO,
-				 bus->reg + NPCM_SMBFIF_CTS);
+				iowrite8(NPCM_SMBFIF_CTS_CLR_FIFO,
+					 bus->reg + NPCM_SMBFIF_CTS);
 		}
 
 		pdebug_lvl2(bus, "int slv stop done2");
 
 		bus->state = SMB_IDLE;
 
+    //if((3 == bus->num) || (5 == bus->num))
+    //{
+	  //  printk("!!!b:%d s stop--\r\n", bus->num);
+    //}
+    //@@
+    if(bus->handle_slave)
+    {
+        bus->handle_slave = false;
+        //printk("!!!b:%d handle master now\r\n", bus->num);
+		    bus->master_or_slave = SMB_MASTER;
+        return IRQ_HANDLED;
+    }
+
 		ret =  IRQ_HANDLED;
 	}
 
@@ -1605,18 +1847,33 @@ static irqreturn_t npcm_smb_int_slave_handler(struct npcm_i2c *bus)
 	if (bus->fifo_use && FIELD_GET(NPCM_SMBFIF_CTS_SLVRSTR,
 				       ioread8(bus->reg + NPCM_SMBFIF_CTS))) {
 		pdebug_lvl2(bus, "int slave restart");
-
+//printk("s resta\r\n");
+    //@@
+    //if(5 == bus->num)
+    //if((3 == bus->num) || (5 == bus->num))
+    //{
+	  //  printk("!!!b:%d s restart\r\n", bus->num);
+    //}
 		bus->stop_ind = SMB_SLAVE_RESTART_IND;
 
-		if (bus->operation == SMB_READ_OPER){
-			npcm_smb_read_from_fifo(bus, npcm_smb_get_fifo_fullness(bus));
-		}
-
-		bus->operation = SMB_WRITE_OPER;
+	if (bus->operation == SMB_READ_OPER){
+      //@@
+    // if(5 == bus->num)
+    //if((3 == bus->num) || (5 == bus->num))
+    // {
+	  //     printk("!!!b:%d s re read fifo\r\n", bus->num);
+    // }
+    //@@
+		//npcm_smb_read_from_fifo(bus, npcm_smb_get_fifo_fullness(bus));
+		npcm_smb_slave_read_from_fifo(bus, npcm_smb_get_fifo_fullness(bus));
+	}
+  //@@
+	//bus->operation = SMB_WRITE_OPER;
 
 		iowrite8(0, bus->reg + NPCM_SMBRXF_CTL);
 
 		pdebug_lvl2(bus, "CB: slv restart");
+    //@@
 		npcm_i2c_slave_send_rd_buf(bus); // send up whatever is on the buffer.
 
 		iowrite8(NPCM_SMBFIF_CTS_CLR_FIFO | NPCM_SMBFIF_CTS_SLVRSTR |
@@ -1625,7 +1882,8 @@ static irqreturn_t npcm_smb_int_slave_handler(struct npcm_i2c *bus)
 		// Slave got an address match with direction bit set so it
 		//	should transmit data
 		// Write till the master will NACK
-		npcm_smb_slave_start_xmit(bus, bus->adap.quirks->max_write_len, bus->slv_wr_buf);
+    //@@
+		//npcm_smb_slave_start_xmit(bus, bus->adap.quirks->max_write_len, bus->slv_wr_buf);
 
 		ret =  IRQ_HANDLED;
 	}
@@ -1636,8 +1894,13 @@ static irqreturn_t npcm_smb_int_slave_handler(struct npcm_i2c *bus)
 		u8 info = 0;
 
 		pdebug_lvl2(bus, "int slave match");
-
-
+    //@@
+   //if(5 == bus->num)
+   //if((3 == bus->num) || (5 == bus->num))
+   //{
+   //   printk("!!!b:%d s match smp_processor_id:0x%x\r\n", bus->num, smp_processor_id());
+   //}
+//printk("s match\r\n");
 		// Address match automatically implies slave mode
 		bus->master_or_slave = SMB_SLAVE;
 
@@ -1658,7 +1921,7 @@ static irqreturn_t npcm_smb_int_slave_handler(struct npcm_i2c *bus)
 			bus->stop_ind = SMB_SLAVE_RCV_IND;
 		}
 
-		if (bus->state == SMB_IDLE) {
+		if (bus->own_slave_addr == 0xFF) { // unknown address
 			// Check which type of address match
 			if (FIELD_GET(NPCM_SMBCST_MATCH , ioread8(bus->reg + NPCM_SMBCST))) {
 				u16 address_match = ((ioread8(bus->reg + NPCM_SMBCST3) & 0x7) << 7) | (ioread8(bus->reg + NPCM_SMBCST2) & 0x7F);
@@ -1682,15 +1945,12 @@ static irqreturn_t npcm_smb_int_slave_handler(struct npcm_i2c *bus)
 					bus->PEC_use = false;
 			} else {
 				if (FIELD_GET(NPCM_SMBCST_GCMATCH , ioread8(bus->reg + NPCM_SMBCST))) {
-					info = (u8)SMB_GC_ADDR;
 					bus->own_slave_addr = 0;
 				} else {
 					if (FIELD_GET(NPCM_SMBCST_ARPMATCH , ioread8(bus->reg + NPCM_SMBCST))) {
-						info = (u8)SMB_ARP_ADDR;
 						bus->own_slave_addr = 0x61;
 					}
 				}
-				// printk("slave match addr 0x%x", bus->own_slave_addr);
 			}
 		} else {
 			//  Slave match can happen in two options:
@@ -1702,19 +1962,21 @@ static irqreturn_t npcm_smb_int_slave_handler(struct npcm_i2c *bus)
 				(bus->stop_ind == SMB_SLAVE_RCV_IND)){
 				// slave transmit after slave receive w/o Slave Stop implies repeated start
 				bus->stop_ind = SMB_SLAVE_RESTART_IND;
-				info = (u8)(bus->slv_rd_ind);
 				npcm_smb_calc_PEC(bus, (bus->own_slave_addr & 0x7F) << 1 | 1);
-				pdebug_lvl2(bus, "slave Sr ");
 			}
 		}
 
 		bus->state = SMB_SLAVE_MATCH;
-
+   
 		if (FIELD_GET(NPCM_SMBST_XMIT, ioread8(bus->reg + NPCM_SMBST))) {
-
+//printk("s xmit\r\n");
 			// Slave got an address match with direction bit set so it
 			//	should transmit data
 			// Write till the master will NACK
+      //if( (3 == bus->num) || (5 == bus->num) )
+      //{
+      //    printk("b:%d s xmit smp_processor_id:0x%x\r\n", bus->num, smp_processor_id());
+      //}
 			npcm_smb_slave_start_xmit(bus, bus->adap.quirks->max_write_len, bus->slv_wr_buf);
 		} else {
 
@@ -1722,44 +1984,20 @@ static irqreturn_t npcm_smb_int_slave_handler(struct npcm_i2c *bus)
 			//	should receive data.
 			// this module does not support saying no to bytes. it will always ACK.
 			pdebug_lvl2(bus, "CB: slv rcv");
-			npcm_i2c_slave_send_rd_buf(bus);
-
+      //@@
+      //if(5 == bus->num)
+      //if((3 == bus->num) || (5 == bus->num))
+      //{
+      //    printk("b:%d s rcv\r\n", bus->num);
+      //}
+      //@@
+			//npcm_i2c_slave_send_rd_buf(bus);
 			npcm_smb_slave_start_receive(bus, bus->adap.quirks->max_read_len, bus->slv_rd_buf);
 		}
 
 
 		iowrite8(NPCM_SMBST_NMATCH, bus->reg + NPCM_SMBST);
-
-#ifdef SMB_RECOVERY_SUPPORT
-
-		// By now, SMB operation state should have been changed from MATCH to SMB_OPER_STARTED.
-		// If state hasn't been changed already, this may suggest that the SMB slave is not ready to
-		// transmit or receive data.
-		//
-		// In addition, when using FIFO, NMATCH bit is cleared only when moving to SMB_OPER_STARTED state.
-		// If NMATCH is not cleared, we would get an endless SMB int.
-		// Therefore, Abort the slave, such that SMB HW and state machine return to a default, functional
-		// state.
-		if (bus->state == SMB_SLAVE_MATCH) {
-			npcm_smb_slave_abort(bus);
-			return IRQ_HANDLED;
-		}
-
-		// Slave abort data
-		// if the SMBus's status is not match current status reg of XMIT
-		// the Slave device will enter dead-lock and stall bus forever
-		// Add this check rule to avoid this condition
-		if ((bus->operation == SMB_READ_OPER  &&
-			bus->stop_ind == SMB_SLAVE_XMIT_IND) ||
-			(bus->operation == SMB_WRITE_OPER
-			&& bus->stop_ind == SMB_SLAVE_RCV_IND)) {
-			npcm_smb_slave_abort(bus);
-			return IRQ_HANDLED;
-		}
-#endif
 		ret =  IRQ_HANDLED;
-
-		// If none of the above - BER should occur
 	}
 
 
@@ -1770,22 +2008,31 @@ static irqreturn_t npcm_smb_int_slave_handler(struct npcm_i2c *bus)
 	    (npcm_smb_tx_fifo_empty(bus) || npcm_smb_rx_fifo_full(bus)))) {
 
 		pdebug_lvl2(bus, "SDA slave set");
-
+    //@@
+    //if(5 == bus->num)
+    //if((3 == bus->num) || (5 == bus->num))
+    //{
+    //   printk("b:%d s sda\r\n", bus->num);
+    //}
 		// Perform slave read. No need to distinguish between last byte and the rest of the bytes.
 		if ((NPCM_SMBST_XMIT & ioread8(bus->reg + NPCM_SMBST)) == 0 ){
 			bus->operation = SMB_READ_OPER;
-			npcm_smb_read_from_fifo(bus, npcm_smb_get_fifo_fullness(bus));
-
-			npcm_smb_clear_fifo_int(bus);
+      //@@
+			//npcm_smb_read_from_fifo(bus, npcm_smb_get_fifo_fullness(bus));
+			npcm_smb_slave_read_from_fifo(bus, npcm_smb_get_fifo_fullness(bus));
+      //@@
+      //if(5 == bus->num)
+      //if((3 == bus->num) || (5 == bus->num))
+      //{
+      //    printk("b:%d s sda-r\r\n", bus->num);
+      //}
 
 			bus->stop_ind = SMB_SLAVE_RCV_IND;
 
 			// Slave got an address match with direction bit clear so it
 			//	should receive data.
 			// this module does not support saying no to bytes. it will always ACK.
-			pdebug_lvl2(bus, "CB: slv rcv");
 			npcm_i2c_slave_send_rd_buf(bus);
-
 			npcm_smb_slave_start_receive(bus, bus->adap.quirks->max_read_len, bus->slv_rd_buf);
 
 		}
@@ -1794,6 +2041,13 @@ static irqreturn_t npcm_smb_int_slave_handler(struct npcm_i2c *bus)
 			// Slave got an address match with direction bit set so it
 			//	should transmit data
 			// Write till the master will NACK
+//printk("s sda-w\r\n");
+      //@@
+      //if(5 == bus->num)
+      //if((3 == bus->num) || (5 == bus->num))
+      //{
+	    //    printk("!!!b:%d s sda w\r\n", bus->num);
+      //}
 			npcm_smb_slave_start_xmit(bus, bus->adap.quirks->max_write_len, bus->slv_wr_buf);
 		}
 
@@ -1803,8 +2057,6 @@ static irqreturn_t npcm_smb_int_slave_handler(struct npcm_i2c *bus)
 		ret =  IRQ_HANDLED;
 	} //SDAST
 
-
-	//spin_unlock(&bus->lock);
 	return ret;
 }
 
@@ -1883,7 +2135,11 @@ static void npcm_smb_master_fifo_read(struct npcm_i2c *bus)
 	fifo_bytes = npcm_smb_get_fifo_fullness(bus);
 
 	rcount = bus->rd_size - bus->rd_ind;
-
+  //@@
+  //if((3 == bus->num) || (5 == bus->num))
+  //{
+	//    printk("!!!b:%d m fr fifo_bytes:0x%x rcount:0x%x smp_processor_id:0x%x\r\n", bus->num, fifo_bytes, rcount, smp_processor_id());
+  //}
 	// In order not to change the RX_TRH during transaction (we found that
 	// this might be problematic if it takes too much time to read the FIFO)
 	//  we read the data in the following way. If the number of bytes to
@@ -1909,15 +2165,26 @@ static void npcm_smb_master_fifo_read(struct npcm_i2c *bus)
 		npcm_smb_eob_int(bus, true);
 		npcm_smb_master_stop(bus);
 
-		npcm_smb_read_from_fifo(bus, fifo_bytes);
+    //@@
+		//npcm_smb_read_from_fifo(bus, fifo_bytes);
+		npcm_smb_master_read_from_fifo(bus, fifo_bytes);
+    //if((3 == bus->num) || (5 == bus->num))
+    //{
+	  //  printk("!!!b:%d line:%d smp_processor_id:0x%x\r\n", bus->num, __LINE__, smp_processor_id());
+    //}
 
 	} else {
 
 		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_READ3);
-		npcm_smb_read_from_fifo(bus, fifo_bytes);
+    //@@
+		//npcm_smb_read_from_fifo(bus, fifo_bytes);
+		npcm_smb_master_read_from_fifo(bus, fifo_bytes);
 		rcount = bus->rd_size - bus->rd_ind;
 		npcm_smb_set_fifo(bus, rcount, -1);
-
+    //if((3 == bus->num) || (5 == bus->num))
+    //{
+	  //  printk("!!!b:%d line:%d smp_processor_id:0x%x\r\n", bus->num, __LINE__, smp_processor_id());
+    //}
 	}
 }
 
@@ -1950,7 +2217,8 @@ static void npcm_smb_int_master_handler_write(struct npcm_i2c *bus)
 			// Issue a STOP condition on the bus
 			npcm_smb_master_stop(bus);
 			// Clear SDA Status bit (by writing dummy byte)
-			npcm_smb_wr_byte(bus, 0xFF);
+      //@@
+			//npcm_smb_wr_byte(bus, 0xFF);
 
 		} else {
 			// last write-byte written on previous int - need to
@@ -1996,6 +2264,12 @@ static void npcm_smb_int_master_handler_write(struct npcm_i2c *bus)
 				npcm_smb_write_PEC(bus);
 				bus->wr_ind++;
 			} else {
+        //@@
+        //if(3 == bus->num)
+        //if((3 == bus->num) || (5 == bus->num))
+        //{
+        //    printk("m b:%d wb: 0x%x\r\n", bus->num, bus->wr_buf[bus->wr_ind]);
+        //}
 				npcm_smb_wr_byte(bus,
 						 bus->wr_buf[bus->wr_ind++]);
 			}
@@ -2003,6 +2277,12 @@ static void npcm_smb_int_master_handler_write(struct npcm_i2c *bus)
 			wcount = bus->wr_size - bus->wr_ind;
 			npcm_smb_set_fifo(bus, -1, wcount);
 			//   WHY NOT: npcm_smb_write_to_fifo_master(bus, wcount);
+        //@@
+        //if(3 == bus->num)
+        //if((3==bus->num) || (5 == bus->num))
+        //{
+        //    printk("m b:%d wf wcount %d: 0x%x\r\n", bus->num, wcount, bus->wr_buf[bus->wr_ind]);
+        //}
 			npcm_smb_write_to_fifo_master(bus, wcount);
 		}
 	}
@@ -2080,7 +2360,8 @@ static void npcm_smb_int_master_handler_read(struct npcm_i2c *bus)
 			bus->stop_ind = SMB_BLOCK_BYTES_ERR_IND;
 			npcm_smb_eob_int(bus, true);
 			npcm_smb_master_stop(bus);
-			npcm_smb_read_from_fifo(bus, npcm_smb_get_fifo_fullness(bus));
+			//npcm_smb_read_from_fifo(bus, npcm_smb_get_fifo_fullness(bus));
+			npcm_smb_master_read_from_fifo(bus, npcm_smb_get_fifo_fullness(bus));
 
 		} else {
 			NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_READ2);
@@ -2094,6 +2375,22 @@ static void npcm_smb_int_master_handler_read(struct npcm_i2c *bus)
 static irqreturn_t npcm_smb_int_master_handler(struct npcm_i2c *bus)
 {
 	irqreturn_t ret = IRQ_NONE;
+	u8 smbfif_cts;
+	if (FIELD_GET(NPCM_SMBST_NMATCH , ioread8(bus->reg + NPCM_SMBST))) {
+		//npcm_smb_master_abort(bus);
+		//iowrite8(NPCM_SMBST_NMATCH, bus->reg + NPCM_SMBST);
+    //@@
+    //printk("b:%d m nack s-r", bus->num);
+    bus->handle_slave = true;
+    //npcm_smb_nack(bus);
+    //npcm_smb_reset(bus);
+		//bus->state = SMB_IDLE;
+		//bus->stop_ind = SMB_BUS_ERR_IND;
+		//npcm_smb_callback(bus, bus->stop_ind, npcm_smb_get_index(bus));
+    //@@
+		//return IRQ_HANDLED;
+		return IRQ_NONE;
+	}
 	// A negative acknowledge has occurred
 	if (FIELD_GET(NPCM_SMBST_NEGACK, ioread8(bus->reg + NPCM_SMBST))) {
 		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_NACK);
@@ -2109,7 +2406,10 @@ static irqreturn_t npcm_smb_int_master_handler(struct npcm_i2c *bus)
 		}
 
 		pdebug_lvl2(bus, "NACK");
-
+    //if( (3 == bus->num) || (5 == bus->num) )
+    //{
+    // printk("b:%d m nack smp_processor_id:0x%x\r\n", bus->num, smp_processor_id());
+    //}
 		// In master write operation, NACK is a problem
 		// number of bytes sent to master less than required
 		bus->stop_ind = SMB_NACK_IND;
@@ -2125,6 +2425,8 @@ static irqreturn_t npcm_smb_int_master_handler(struct npcm_i2c *bus)
 		npcm_smb_callback(bus, bus->stop_ind, bus->wr_ind);
 		ret =  IRQ_HANDLED;
 
+		return ret;
+
 	}
 
 	// Master mode: a Bus Error has been identified
@@ -2132,6 +2434,12 @@ static irqreturn_t npcm_smb_int_master_handler(struct npcm_i2c *bus)
 		// Check whether bus arbitration or Start or Stop during data
 		// xfer bus arbitration problem should not result in recovery
 		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_BER);
+		pdebug_lvl2(bus, "BER_M");
+    //@@
+    //if((3 == bus->num) || (5 == bus->num))
+    //{
+	  //  printk("!!!b:%d m BER smp_processor_id:0x%x\r\n", bus->num, smp_processor_id());
+    //}
 		if (npcm_smb_is_master(bus)) {
 			// Only current master is allowed to issue stop
 			bus->stop_ind = SMB_BUS_ERR_IND;
@@ -2141,7 +2449,7 @@ static irqreturn_t npcm_smb_int_master_handler(struct npcm_i2c *bus)
 			if (bus->retry_count-- > 1) {
 				// Perform a retry (generate a start condition)
 				// as soon as the SMBus is free
-				pdebug(bus, "retry-BER");
+				pdebug_lvl2(bus, "retry-BER");
 				iowrite8(NPCM_SMBST_BER, bus->reg + NPCM_SMBST);
 				npcm_smb_master_start(bus);
 				return IRQ_HANDLED;
@@ -2161,6 +2469,11 @@ static irqreturn_t npcm_smb_int_master_handler(struct npcm_i2c *bus)
 	    (FIELD_GET(NPCM_SMBCST3_EO_BUSY,
 		       ioread8(bus->reg + NPCM_SMBCST3)))) {
 		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_EOB);
+    //@@
+    //if((3 == bus->num) || (5 == bus->num))
+    //{
+	  //  printk("!!!b:%d m EOB smp_processor_id:0x%x\r\n", bus->num, smp_processor_id());
+    //}
 		pdebug_lvl2(bus, "EOB  ");
 		npcm_smb_eob_int(bus, false);
 		bus->state = SMB_IDLE;
@@ -2172,7 +2485,10 @@ static irqreturn_t npcm_smb_int_master_handler(struct npcm_i2c *bus)
 	if (FIELD_GET(NPCM_SMBST_STASTR, ioread8(bus->reg + NPCM_SMBST))) {
 		pdebug_lvl2(bus, "stall");
 		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_STALL);
-
+    //if( (3 == bus->num) || (5 == bus->num) )
+    //{
+    //   printk("b:%d stall\r\n", bus->num);
+    //}
 		// Check for Quick Command SMBus protocol
 		if (npcm_smb_is_quick(bus)) {
 			// Update status
@@ -2202,63 +2518,88 @@ static irqreturn_t npcm_smb_int_master_handler(struct npcm_i2c *bus)
 	    (npcm_smb_tx_fifo_empty(bus) || npcm_smb_rx_fifo_full(bus)))) {
 		// Status Bit is cleared by writing to or reading from SDA
 		// (depending on current direction)
-		switch (bus->state) {
-		// Handle unsuccessful bus mastership
-		case SMB_IDLE:
-			bus->stop_ind = SMB_WAKE_UP_IND;
-			npcm_smb_master_abort(bus);
-			return IRQ_HANDLED;
 
-		case SMB_MASTER_START:
+		// Send address:
+		if (bus->state == SMB_IDLE){
 			if (npcm_smb_is_master(bus)) {
-				u8 addr_byte = bus->dest_addr;
-
+				bus->stop_ind = SMB_WAKE_UP_IND;
+       //if( (3 == bus->num) || (5 == bus->num) )
+       //{
+       //   printk("b:%d send addr\r\n", bus->num);
+       //}
 				bus->crc_data = 0;
-				if (npcm_smb_is_quick(bus)) {
+
+				// test stall on start
+				if (npcm_smb_is_quick(bus) || (bus->read_block_use == true)) {
 					// Need to stall after successful
 					// completion of sending address byte
 					npcm_smb_stall_after_start(bus, true);
-					bus->operation = SMB_WRITE_OPER;
-				} else if (bus->wr_size == 0) {
-					// Set direction to Read
-					addr_byte |= (u8)0x1;
-					bus->operation = SMB_READ_OPER;
 				} else {
-					bus->operation = SMB_WRITE_OPER;
+          //@@
+					//npcm_smb_stall_after_start(bus, false);
 				}
-
-	// Receiving one byte only - stall after successful completion of
-	// sending address byte. If we NACK here, and slave doesn't ACK the
-	// address, we might unintentionally NACK the next multi-byte read
+				// Receiving one byte only - stall after successful completion of
+				// sending address byte. If we NACK here, and slave doesn't ACK the
+				// address, we might unintentionally NACK the next multi-byte read
 				if (bus->wr_size == 0 && bus->rd_size == 1)
 					npcm_smb_stall_after_start(bus, true);
 
-				// Write the address to the bus
+#if 1
+				// Initiate SMBus master transaction
+				// Generate a Start condition on the SMBus
+
+				// select bank 1 for FIFO regs
+				npcm_smb_select_bank(bus, SMB_BANK_1);
+
+				smbfif_cts = ioread8(bus->reg + NPCM_SMBFIF_CTS);
+
+				// clear FIFO and relevant status bits.
+				iowrite8((smbfif_cts & (~NPCM_SMBFIF_CTS_SLVRSTR)) |
+					 NPCM_SMBFIF_CTS_CLR_FIFO,
+					 bus->reg + NPCM_SMBFIF_CTS);
+
+				// and enable it
+				iowrite8((smbfif_cts & (~NPCM_SMBFIF_CTS_SLVRSTR)) |
+					 NPCM_SMBFIF_CTS_RXF_TXE,
+					 bus->reg + NPCM_SMBFIF_CTS);
+
+				// Configure the FIFO
+				//threshold according to the needed # of bytes to read.
+				npcm_smb_set_fifo(bus, bus->rd_size, bus->wr_size);
+#endif
 				bus->state = SMB_OPER_STARTED;
-				npcm_smb_wr_byte(bus, addr_byte);
-			} else {
-				dev_err(bus->dev,
-					"SDA, bus%d is not master, wr %d 0x%x...\n",
-					bus->num, bus->wr_size,
-					bus->wr_buf[0]);
+
+				if (npcm_smb_is_quick(bus) || (bus->wr_size > 0))
+        {
+
+					npcm_smb_wr_byte(bus, bus->dest_addr);
+        }
+				else
+					npcm_smb_wr_byte(bus, bus->dest_addr | 0x01);
 			}
-			break;
 
+			return IRQ_HANDLED;
+
+
+		}
 		// SDA status is set - transmit or receive: Handle master mode
-		case SMB_OPER_STARTED:
+		else {
 			if ((NPCM_SMBST_XMIT & ioread8(bus->reg + NPCM_SMBST)) == 0 ){
+         //if((3 == bus->num) || (5 == bus->num))
+         //{
+	       //    printk("!!!b:%d m sda r smp_processor_id:0x%x\r\n", bus->num, smp_processor_id());
+         //}
 				bus->operation = SMB_READ_OPER;
 				npcm_smb_int_master_handler_read(bus);
 			}
 			else {
+         //if((3 == bus->num) || (5 == bus->num))
+         //{
+	       //    printk("!!!b:%d m sda w smp_processor_id:0x%x\r\n", bus->num, smp_processor_id());
+         //}
 				bus->operation = SMB_WRITE_OPER;
 				npcm_smb_int_master_handler_write(bus);
 			}
-
-			break;
-		default:
-			dev_err(bus->dev, "i2c%d master sda err on state machine\n",
-				bus->num);
 		}
 		ret =  IRQ_HANDLED;
 	}
@@ -2509,6 +2850,9 @@ static bool npcm_smb_init_module(struct npcm_i2c *bus, enum smb_mode mode,
 		 bus->reg + NPCM_SMBCTL1);
 
 	npcm_smb_int_enable(bus, true);
+
+	npcm_smb_reset(bus);
+
 	return true;
 }
 
@@ -2546,26 +2890,64 @@ static int __npcm_i2c_init(struct npcm_i2c *bus, struct platform_device *pdev)
 static irqreturn_t npcm_i2c_bus_irq(int irq, void *dev_id)
 {
 	irqreturn_t ret;
+  //unsigned long flags;
 	struct npcm_i2c *bus = dev_id;
 
 	bus->int_cnt++;
-
+  //if( (3 == bus->num) || (5 == bus->num) )
+  //{
+  //   printk("b:%d irq smp_processor_id:0x%x\r\n", bus->num, smp_processor_id());
+  //}
+
+
+	//spin_lock(&bus->lock);
+	//spin_lock_irqsave(&bus->lock, flags);
+	spin_lock(&bus->lock);
+  //if( (3 == bus->num) || (5 == bus->num) )
+  //{
+  //   printk("b:%d smp_processor_id:0x%x ++\r\n", bus->num, smp_processor_id());
+  //}
 	if(npcm_smb_is_master(bus))
 		bus->master_or_slave = SMB_MASTER;
 
-	if (bus->master_or_slave == SMB_MASTER)	{
+	if (!bus->handle_slave && bus->master_or_slave == SMB_MASTER)	{
  		bus->int_time_stamp = jiffies;
 		ret = npcm_smb_int_master_handler(bus);
-		if (ret == IRQ_HANDLED)
+		if (ret == IRQ_HANDLED){
+			//spin_unlock(&bus->lock);
+	    //spin_unlock_irqrestore(&bus->lock, flags);
+			spin_unlock(&bus->lock);
+      //if( (3 == bus->num) || (5 == bus->num) )
+      //{
+      //   printk("b:%d line:%d --\r\n", bus->num, __LINE__);
+      //}
 			return ret;
+		}
 	}
 #if IS_ENABLED(CONFIG_I2C_SLAVE)
 	if (bus->slave) {
 		bus->master_or_slave = SMB_SLAVE;
-		return npcm_smb_int_slave_handler(bus);
+		ret = npcm_smb_int_slave_handler(bus);
+		if (ret == IRQ_HANDLED){
+			//spin_unlock(&bus->lock);
+	    //spin_unlock_irqrestore(&bus->lock, flags);
+			spin_unlock(&bus->lock);
+      //if( (3 == bus->num) || (5 == bus->num) )
+      //{
+      //   printk("b:%d line:%d --\r\n", bus->num, __LINE__ );
+      //}
+			return ret;
+		}
 	}
 #endif
 
+	//spin_unlock(&bus->lock);
+	//spin_unlock_irqrestore(&bus->lock, flags);
+	spin_unlock(&bus->lock);
+  //if( (3 == bus->num) || (5 == bus->num) )
+  //{
+  //     printk("b:%d line:%d --\r\n", bus->num, __LINE__);
+  //}
 	return IRQ_HANDLED;
 }
 
@@ -2574,13 +2956,17 @@ static bool npcm_smb_master_start_xmit(struct npcm_i2c *bus,
 				       u8 *write_data, u8 *read_data,
 				       bool use_PEC, bool use_read_block)
 {
-	u8 smbfif_cts;
-
 	// Allow only if bus is not busy
 	if (bus->state != SMB_IDLE) {
-		dev_err(bus->dev, "\tbus%d->state != SMB_IDLE\n", bus->num);
+		pdebug_lvl2(bus, "xmit not IDLE\n");
+    //@@
+    //if( (3 == bus->num) || (5 == bus->num) )
+    //{
+    //   printk("b:%d busy line:%d --\r\n", bus->num, __LINE__);
+    //}
 		return false;
 	}
+  bus->master_or_slave = SMB_MASTER;
 
 	bus->dest_addr = (u8)(slave_addr << 1);// Translate 7bit to 8bit format
 	bus->wr_buf = write_data;
@@ -2599,10 +2985,12 @@ static bool npcm_smb_master_start_xmit(struct npcm_i2c *bus,
 	else
 		bus->operation = SMB_WRITE_OPER;
 
-
-	// Initiate SMBus master transaction
-	// Generate a Start condition on the SMBus
-	if (bus->fifo_use) {
+	bus->int_cnt = 0;
+	bus->event_log = 0;
+	pdebug_lvl2(bus, "xmit ");
+#if 1
+  if (bus->fifo_use) {
+    u8 smbfif_cts;
 		// select bank 1 for FIFO regs
 		npcm_smb_select_bank(bus, SMB_BANK_1);
 
@@ -2614,35 +3002,55 @@ static bool npcm_smb_master_start_xmit(struct npcm_i2c *bus,
 			 bus->reg + NPCM_SMBFIF_CTS);
 
 		// and enable it
-		iowrite8((smbfif_cts & (~NPCM_SMBFIF_CTS_SLVRSTR)) |
-			 NPCM_SMBFIF_CTS_RXF_TXE,
-			 bus->reg + NPCM_SMBFIF_CTS);
+		//iowrite8((smbfif_cts & (~NPCM_SMBFIF_CTS_SLVRSTR)) |
+		//	 NPCM_SMBFIF_CTS_RXF_TXE,
+		//	 bus->reg + NPCM_SMBFIF_CTS);
 
 		// Configure the FIFO
 		//threshold according to the needed # of bytes to read.
-		npcm_smb_set_fifo(bus, nread, nwrite);
+		//npcm_smb_set_fifo(bus, nread, nwrite);
 
 	}
-
-	bus->int_cnt = 0;
-	bus->event_log = 0;
-	pdebug_lvl2(bus, "xmit ");
-
-	// Update driver state
+#endif
 	// Allow only if bus is not busy
 	if (bus->state != SMB_IDLE) {
-		dev_err(bus->dev, "\tbus%d->state(2) != SMB_IDLE\n", bus->num);
+
+		pdebug(bus, "xmit not IDLE\n");
+    //@@
+    //if( (3 == bus->num) || (5 == bus->num) )
+    //{
+    //   printk("b:%d busy line:%d --\r\n", bus->num, __LINE__);
+    //}
+        if(bus->slave)
+        {
+            bus->master_or_slave = SMB_SLAVE;
+        }
 		return false;
 	}
+	bus->state = SMB_IDLE;
+	// bus->master_or_slave = SMB_MASTER;
+
+	if (npcm_smb_wait_for_bus_free(bus) == false)
+  {
+    //@@
+    //if( (3 == bus->num) || (5 == bus->num) )
+    //{
+    //   printk("b:%d busy line:%d --\r\n", bus->num, __LINE__);
+    //}
+    if(bus->slave)
+    {
+      bus->master_or_slave = SMB_SLAVE;
+    }
+		return false;
+  }
 
-	bus->state = SMB_MASTER_START;
-	bus->master_or_slave = SMB_MASTER;
-
+	npcm_smb_stall_after_start(bus, true);
 	npcm_smb_master_start(bus);
 
 	return true;
 }
 
+
 static int npcm_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 				int num)
 {
@@ -2654,22 +3062,30 @@ static int npcm_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 	u8 slave_addr;
 	int ret = 0;
 	int timeout = bus->adap.timeout;
-	unsigned long timeout1;
 	bool read_block = false;
-
-
+  //@@
+  //u8 loop;
+  //@@
+  //if( (3 == bus->num) || (5 == bus->num) )
+  //{
+  //   printk("b:%d start smp_processor_id:0x%x\r\n", bus->num, smp_processor_id());
+  //}
 
 	if (num > 2 || num < 1) {
 		pr_err("I2C command not supported, num of msgs = %d\n", num);
 		return -EINVAL;
 	}
 
+	spin_lock_irqsave(&bus->lock, flags);
+
 	msg0 = &msgs[0];
 	slave_addr = msg0->addr;
 	if (msg0->flags & I2C_M_RD) { // read
 		if (num == 2) {
 			pr_err(" num = 2 but first msg is rd instead of wr\n");
-			return -EINVAL;
+			ret = -EINVAL;
+	    spin_unlock_irqrestore(&bus->lock, flags);
+			goto xfer_end;
 		}
 		nwrite = 0;
 		write_data = NULL;
@@ -2691,11 +3107,15 @@ static int npcm_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 			if (slave_addr != msg1->addr) {
 				pr_err("SA==%02x but msg1->addr == %02x\n",
 				       slave_addr, msg1->addr);
-				return -EINVAL;
+				ret = -EINVAL;
+	      spin_unlock_irqrestore(&bus->lock, flags);
+				goto xfer_end;
 			}
 			if ((msg1->flags & I2C_M_RD) == 0) {
 				pr_err("num = 2 but both msg are write.\n");
-				return -EINVAL;
+				ret = -EINVAL;
+	      spin_unlock_irqrestore(&bus->lock, flags);
+				goto xfer_end;
 			}
 			if (msg1->flags & I2C_M_RECV_LEN) {
 				nread = 1;
@@ -2728,20 +3148,30 @@ static int npcm_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 
 	if (nwrite >= 32 * 1024 ||  nread >= 32 * 1024) {
 		pr_err("i2c%d buffer too big\n", bus->num);
-		return -EINVAL;
-	}
-
-	timeout1 = jiffies + bus->adap.timeout;
-	while (((ioread8(bus->reg + NPCM_SMBCST) & NPCM_SMBCST_BB) == 1) ||
-		(bus->state != SMB_IDLE)){
-		if (time_after(jiffies, timeout1)) {
-			pdebug(bus, "ETIMEDOUT");
-			return -ETIMEDOUT;
-		}
-		cpu_relax();
-	}
-
-	spin_lock_irqsave(&bus->lock, flags);
+		ret = -EINVAL;
+	  spin_unlock_irqrestore(&bus->lock, flags);
+		goto xfer_end;
+	}
+
+	if (npcm_smb_wait_for_bus_free(bus) == false) {
+		ret = bus->cmd_err;
+    //@@
+    //if( (3 == bus->num) || (5 == bus->num) )
+    //{
+    //    printk("b:%d no free bus bus->cmd_err: 0x%x\r\n", bus->num, bus->cmd_err);
+    //}
+    spin_unlock_irqrestore(&bus->lock, flags);
+		goto xfer_end;
+	}
+
+  //@@
+ //if( (3 == bus->num) || (5 == bus->num) )
+ //{
+ //   for(loop=0; loop<nwrite; loop++)
+ //   {
+ //       printk("b:%d wdata: 0x%x\r\n", bus->num, write_data[loop]);
+ //   }
+ //}
 
 	npcm_smb_init_params(bus);
 
@@ -2751,11 +3181,14 @@ static int npcm_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 				       write_data, read_data, 0, read_block) == false)
 		ret = -(EBUSY);
 
+	spin_unlock_irqrestore(&bus->lock, flags);
+
 	if (ret != -(EBUSY)) {
+
 		time_left = wait_for_completion_timeout(&bus->cmd_complete,
 							timeout);
 
-		if (time_left == 0 && bus->cmd_err == -EPERM) {
+		if (time_left == 0) {
 			NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_TO);
 			pdebug_lvl2(bus, "xfer TO");
 
@@ -2766,20 +3199,21 @@ static int npcm_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 				// Reset driver status
 				bus->state = SMB_IDLE;
 			}
-
-			ret = -ETIMEDOUT;
-		} else {
-			ret = bus->cmd_err;
 		}
+		ret = bus->cmd_err;
+
 	} else {
 #if defined(CONFIG_I2C_DEBUG_BUS)
 		pdebug_lvl2(bus, "busy");
 #endif
+		ret = bus->cmd_err;
 	}
 
+xfer_end:
 	bus->msgs = NULL;
 	bus->msgs_num = 0;
-	spin_unlock_irqrestore(&bus->lock, flags);
+
+	//spin_unlock_irqrestore(&bus->lock, flags);
 
 	// If nothing went wrong, return number of messages xferred.
 	if (ret >= 0)
@@ -2828,6 +3262,7 @@ static int  npcm_i2c_probe_bus(struct platform_device *pdev)
 	bus = devm_kzalloc(&pdev->dev, sizeof(*bus), GFP_KERNEL);
 	if (!bus)
 		return -ENOMEM;
+	buss[bus->adap.nr] = bus;
 
 #ifdef CONFIG_OF
 	num = of_alias_get_id(pdev->dev.of_node, "i2c");
@@ -2915,6 +3350,7 @@ static int  npcm_i2c_probe_bus(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, bus);
 	pr_info("i2c bus %d registered\n", bus->adap.nr);
+	buss[bus->adap.nr] = bus;
 
 	return 0;
 }
-- 
2.17.1

